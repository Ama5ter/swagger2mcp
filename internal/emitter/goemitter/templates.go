package goemitter

import (
	"fmt"
	"strings"

	genspec "github.com/mark3labs/swagger2mcp/internal/spec"
)

type templateData struct {
	ToolName    string
	ModuleName  string
	serviceName string
	service     *genspec.ServiceModel
}

func newTemplateData(toolName, moduleName string, sm *genspec.ServiceModel) templateData {
	serviceTitle := ""
	if sm != nil {
		serviceTitle = strings.TrimSpace(sm.Title)
	}
	return templateData{
		ToolName:    strings.TrimSpace(toolName),
		ModuleName:  strings.TrimSpace(moduleName),
		serviceName: serviceTitle,
		service:     sm,
	}
}

func (d templateData) serviceTitle() string {
	return d.serviceName
}

func (d templateData) apply(content string) string {
	replacer := strings.NewReplacer(
		"{{MODULE}}", d.ModuleName,
		"{{TOOL_NAME}}", d.ToolName,
		"{{SERVICE_TITLE}}", d.serviceName,
	)
	return replacer.Replace(content)
}

func (d templateData) render(content string) string {
	return normalize(d.apply(content))
}

func normalize(content string) string {
	trimmed := strings.TrimSpace(content)
	if trimmed == "" {
		return ""
	}
	return trimmed + "\n"
}

// Templates and content renderers

func renderGoMod(data templateData) string {
	return normalize(fmt.Sprintf("module %s\n\ngo 1.23\n\nrequire github.com/mark3labs/mcp-go v0.40.0\n\n", data.ModuleName))
}

func renderReadme(data templateData) string {
	lines := []string{
		fmt.Sprintf("# %s", data.ToolName),
		"",
		fmt.Sprintf("Generated MCP tool for %s", data.serviceTitle()),
		"",
		"This project was generated by swagger2mcp and exposes MCP methods to query your API documentation.",
		"",
		"- Methods: listEndpoints, searchEndpoints, getEndpointDetails, listSchemas, getSchemaDetails",
		"- Runtime: Go (github.com/mark3labs/mcp-go)",
		"",
		"Build:",
		"",
		"```",
		"go build ./...",
		"```",
		"",
	}
	return normalize(strings.Join(lines, "\n"))
}

func renderMainGo(data templateData) string {
	return normalize(fmt.Sprintf(`package main

import (
    "log"

    goserver "github.com/mark3labs/mcp-go/server"

    "%s/internal/mcp"
    "%s/internal/spec"
)

func main() {
    // Load the embedded service model
    sm, err := spec.Load()
    if err != nil {
        log.Fatalf("load model: %%v", err)
    }

    // Create MCP server and serve over stdio
    srv := mcp.NewMCPServer(sm)
    if err := goserver.ServeStdio(srv); err != nil {
        log.Fatalf("mcp stdio: %%v", err)
    }
}
`, data.ModuleName, data.ModuleName))
}

func renderEditorConfig() string {
	return normalize(`root = true

[*]
charset = utf-8
end_of_line = lf
insert_final_newline = true
indent_style = space
indent_size = 2
trim_trailing_whitespace = true
`)
}

func renderMakefileGo() string {
	return normalize(`# Simple Makefile for Go MCP tool

.PHONY: help build test fmt tidy

help:
	@echo "Targets: build test fmt tidy"

build:
	go build ./...

test:
	go test ./...

fmt:
	go fmt ./...

tidy:
	go mod tidy
`)
}

// Copy of the generator IM types for the generated project.
func renderSpecModelGo() string {
	return normalize(`package spec

// Internal Model (IM) definitions used by the generated MCP tool.

type HttpMethod string

const (
    GET     HttpMethod = "get"
    POST    HttpMethod = "post"
    PUT     HttpMethod = "put"
    DELETE  HttpMethod = "delete"
    PATCH   HttpMethod = "patch"
    HEAD    HttpMethod = "head"
    OPTIONS HttpMethod = "options"
    TRACE   HttpMethod = "trace"
)

type ServiceModel struct {
    Title       string
    Version     string
    Description string
    Servers     []Server
    Tags        []string
    Endpoints   []EndpointModel
    Schemas     map[string]Schema // by name/ref
}

type Server struct {
    URL         string
    Description string
}

type EndpointModel struct {
    ID          string // method+path
    Method      HttpMethod
    Path        string
    Summary     string
    Description string
    Tags        []string
    Parameters  []ParameterModel
    RequestBody *RequestBodyModel
    Responses   []ResponseModel
}

type ParameterModel struct {
    Name     string
    In       string // path|query|header|cookie
    Required bool
    Schema   *SchemaOrRef
}

type RequestBodyModel struct {
    Content  []Media
    Required bool
}

type ResponseModel struct {
    Status      string // 200, 4xx, default
    Description string
    Content     []Media
}

type Media struct {
    Mime   string
    Schema *SchemaOrRef
    Example any
}

type Schema struct {
    Name        string
    Type        string
    Properties  map[string]*SchemaOrRef
    Required    []string
    Items       *SchemaOrRef
    AllOf       []*SchemaOrRef
    AnyOf       []*SchemaOrRef
    OneOf       []*SchemaOrRef
    Description string
    Enum        []any
    Format      string
    Example     any
}

type SchemaRef struct{ Ref string }

type SchemaOrRef struct {
    Schema *Schema
    Ref    *SchemaRef
}
`)
}

func renderSpecLoaderGo() string {
	return normalize(`package spec

import (
    "embed"
    "encoding/json"
    "errors"
)

//go:embed model.json
var rawModel []byte
// reference embed so the import is not considered unused by older toolchains
var _ embed.FS

// Load returns the embedded ServiceModel.
func Load() (*ServiceModel, error) {
    if len(rawModel) == 0 {
        return nil, errors.New("empty embedded model")
    }
    var sm ServiceModel
    if err := json.Unmarshal(rawModel, &sm); err != nil {
        return nil, err
    }
    return &sm, nil
}
`)
}

func renderMCPBootstrapGo(data templateData) string {
	return data.render(`package mcp

import (
    "context"
    "fmt"

    "github.com/mark3labs/mcp-go/mcp"
    goserver "github.com/mark3labs/mcp-go/server"

    methods "{{MODULE}}/internal/mcp/methods"
    "{{MODULE}}/internal/spec"
)

// NewMCPServer creates and configures an MCP server with tools backed by the ServiceModel.
func NewMCPServer(sm *spec.ServiceModel) *goserver.MCPServer {
    name := sm.Title
    if name == "" { name = "mcp-tool" }
    srv := goserver.NewMCPServer(name, sm.Version,
        goserver.WithToolCapabilities(true),
        goserver.WithInstructions("This server exposes tools to query your API documentation."),
        goserver.WithRecovery(),
    )

    // listEndpoints tool (no args)
    srv.AddTool(mcp.NewTool("listEndpoints",
        mcp.WithDescription("Show API overview and routing summary"),
        mcp.WithInputSchema[struct{}](),
    ), func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
        overview := methods.FormatEndpointsOverview(sm)
        return &mcp.CallToolResult{
            Content: []mcp.Content{mcp.TextContent{Type: "text", Text: overview}},
        }, nil
    })

    // searchEndpoints tool
    type SearchArgs struct {
        Keyword     string
        Tag         string
        Method      string
        PathPattern string
    }
    srv.AddTool(mcp.NewTool("searchEndpoints",
        mcp.WithDescription("Search endpoints by keyword, tag, method, or path regex"),
        mcp.WithInputSchema[SearchArgs](),
    ), func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
        var args SearchArgs
        _ = req.BindArguments(&args)
        out := methods.SearchEndpoints(sm, methods.SearchQuery{Keyword: args.Keyword, Tag: args.Tag, Method: args.Method, PathPattern: args.PathPattern})
        return &mcp.CallToolResult{Content: []mcp.Content{mcp.TextContent{Type: "text", Text: fmt.Sprintf("%d matches", len(out))}}, StructuredContent: out}, nil
    })

    // getEndpointDetails tool
    type GetEPArgs struct {
        ID     string
        Method string
        Path   string
    }
    srv.AddTool(mcp.NewTool("getEndpointDetails",
        mcp.WithDescription("Get endpoint details by id or method+path"),
        mcp.WithInputSchema[GetEPArgs](),
    ), func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
        var a GetEPArgs
        _ = req.BindArguments(&a)
        var ep *spec.EndpointModel
        var ok bool
        if a.ID != "" {
            ep, ok = methods.GetEndpointDetails(sm, a.ID)
        } else {
            ep, ok = methods.GetEndpointDetails(sm, a.Method, a.Path)
        }
        if !ok || ep == nil {
            return &mcp.CallToolResult{IsError: true, Content: []mcp.Content{mcp.TextContent{Type: "text", Text: "endpoint not found"}}}, nil
        }
        // Format detailed text output
        text := methods.FormatEndpointDetails(ep, sm)
        return &mcp.CallToolResult{StructuredContent: ep, Content: []mcp.Content{mcp.TextContent{Type: "text", Text: text}}}, nil
    })

    // listSchemas tool
    srv.AddTool(mcp.NewTool("listSchemas",
        mcp.WithDescription("List schema names"),
        mcp.WithInputSchema[struct{}](),
    ), func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
        out := methods.ListSchemas(sm)
        return &mcp.CallToolResult{StructuredContent: out, Content: []mcp.Content{mcp.TextContent{Type: "text", Text: fmt.Sprintf("%d schemas", len(out))}}}, nil
    })

    // getSchemaDetails tool
    type GetSchemaArgs struct { Name string }
    srv.AddTool(mcp.NewTool("getSchemaDetails",
        mcp.WithDescription("Get details for a schema by name"),
        mcp.WithInputSchema[GetSchemaArgs](),
    ), func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
        var a GetSchemaArgs
        if err := req.BindArguments(&a); err != nil { return nil, err }
        sc, ok := methods.GetSchemaDetails(sm, a.Name)
        if !ok { return &mcp.CallToolResult{IsError: true, Content: []mcp.Content{mcp.TextContent{Type: "text", Text: "schema not found"}}}, nil }
        // Format detailed schema output
        text := methods.FormatSchemaDetails(sc, sm)
        return &mcp.CallToolResult{StructuredContent: sc, Content: []mcp.Content{mcp.TextContent{Type: "text", Text: text}}}, nil
    })

    return srv
}
`)
}

func renderListEndpointsGo(data templateData) string {
	return data.render(`package methods

import (
    "fmt"
    "sort"
    "strings"

    "` + "{{MODULE}}" + `/internal/spec"
)

type EndpointSummary struct {
    ID          string   ` + "`json:\"id\"`" + `
    Method      string   ` + "`json:\"method\"`" + `
    Path        string   ` + "`json:\"path\"`" + `
    Summary     string   ` + "`json:\"summary\"`" + `
    Description string   ` + "`json:\"description\"`" + `
    Tags        []string ` + "`json:\"tags\"`" + `
    Parameters  []ParameterSummary ` + "`json:\"parameters\"`" + `
    Responses   []ResponseSummary  ` + "`json:\"responses\"`" + `
}

type ParameterSummary struct {
    Name     string ` + "`json:\"name\"`" + `
    In       string ` + "`json:\"in\"`" + `
    Required bool   ` + "`json:\"required\"`" + `
    Type     string ` + "`json:\"type\"`" + `
    Enum     []any  ` + "`json:\"enum,omitempty\"`" + `
}

type ResponseSummary struct {
    Status      string ` + "`json:\"status\"`" + `
    Description string ` + "`json:\"description\"`" + `
}

func ListEndpoints(sm *spec.ServiceModel) []EndpointSummary {
    out := make([]EndpointSummary, 0, len(sm.Endpoints))
    for _, ep := range sm.Endpoints {
        // Build parameters
        params := make([]ParameterSummary, 0, len(ep.Parameters))
        for _, p := range ep.Parameters {
            paramType := "unknown"
            var enumValues []any
            if p.Schema != nil && p.Schema.Schema != nil {
                if p.Schema.Schema.Type != "" {
                    paramType = p.Schema.Schema.Type
                }
                enumValues = p.Schema.Schema.Enum
            }
            params = append(params, ParameterSummary{
                Name:     p.Name,
                In:       p.In,
                Required: p.Required,
                Type:     paramType,
                Enum:     enumValues,
            })
        }
        
        // Build responses
        responses := make([]ResponseSummary, 0, len(ep.Responses))
        for _, r := range ep.Responses {
            responses = append(responses, ResponseSummary{
                Status:      r.Status,
                Description: r.Description,
            })
        }
        
        out = append(out, EndpointSummary{
            ID:          ep.ID, 
            Method:      string(ep.Method), 
            Path:        ep.Path, 
            Summary:     ep.Summary, 
            Description: ep.Description,
            Tags:        append([]string(nil), ep.Tags...),
            Parameters:  params,
            Responses:   responses,
        })
    }
    sort.Slice(out, func(i, j int) bool {
        if out[i].Path == out[j].Path { return out[i].Method < out[j].Method }
        return out[i].Path < out[j].Path
    })
    return out
}

// FormatEndpointsOverview formats a comprehensive overview of all endpoints
func FormatEndpointsOverview(sm *spec.ServiceModel) string {
    endpoints := ListEndpoints(sm)
    if len(endpoints) == 0 {
        return "无可用接口"
    }

    var lines []string
    lines = append(lines, fmt.Sprintf("API 接口概览 (%d 个接口)", len(endpoints)))
    lines = append(lines, "")

    // 按标签分组统计
    tagStats := make(map[string]int)
    methodStats := make(map[string]int)
    
    for _, ep := range endpoints {
        methodStats[ep.Method]++
        for _, tag := range ep.Tags {
            tagStats[tag]++
        }
    }
    
    // 显示方法统计
    lines = append(lines, "HTTP 方法分布:")
    for method, count := range methodStats {
        lines = append(lines, fmt.Sprintf("  %s: %d 个接口", strings.ToUpper(method), count))
    }
    lines = append(lines, "")
    
    // 显示标签统计 (取前10个)
    if len(tagStats) > 0 {
        lines = append(lines, "服务模块分布:")
        // 按数量排序
        type tagCount struct {
            tag   string
            count int
        }
        var tagList []tagCount
        for tag, count := range tagStats {
            tagList = append(tagList, tagCount{tag, count})
        }
        sort.Slice(tagList, func(i, j int) bool {
            return tagList[i].count > tagList[j].count
        })
        
        // 显示前10个最多的标签
        maxShow := 10
        if len(tagList) < maxShow {
            maxShow = len(tagList)
        }
        for i := 0; i < maxShow; i++ {
            lines = append(lines, fmt.Sprintf("  %s: %d 个接口", tagList[i].tag, tagList[i].count))
        }
        if len(tagList) > 10 {
            lines = append(lines, fmt.Sprintf("  ... 还有 %d 个其他服务模块", len(tagList)-10))
        }
        lines = append(lines, "")
    }
    
    // 显示主要路由路径
    lines = append(lines, "主要路由路径:")
    pathPrefixes := make(map[string]int)
    for _, ep := range endpoints {
        // 提取路径前缀 (前两级路径)
        parts := strings.Split(strings.Trim(ep.Path, "/"), "/")
        if len(parts) >= 2 {
            prefix := "/" + parts[0] + "/" + parts[1]
            pathPrefixes[prefix]++
        } else if len(parts) == 1 && parts[0] != "" {
            prefix := "/" + parts[0]
            pathPrefixes[prefix]++
        }
    }
    
    // 按数量排序路径前缀
    type pathCount struct {
        path  string
        count int
    }
    var pathList []pathCount
    for path, count := range pathPrefixes {
        pathList = append(pathList, pathCount{path, count})
    }
    sort.Slice(pathList, func(i, j int) bool {
        return pathList[i].count > pathList[j].count
    })
    
    // 显示前10个最常用的路径前缀
    maxPaths := 10
    if len(pathList) < maxPaths {
        maxPaths = len(pathList)
    }
    for i := 0; i < maxPaths; i++ {
        lines = append(lines, fmt.Sprintf("  %s: %d 个接口", pathList[i].path, pathList[i].count))
    }
    if len(pathList) > 10 {
        lines = append(lines, fmt.Sprintf("  ... 还有 %d 个其他路径", len(pathList)-10))
    }
    lines = append(lines, "")
    
    // 显示所有接口端点列表 (功能总结和路由)
    lines = append(lines, "所有接口端点:")
    for _, ep := range endpoints {
        summary := ep.Summary
        if summary == "" {
            summary = "无描述"
        }
        lines = append(lines, fmt.Sprintf("  %s %s - %s", strings.ToUpper(ep.Method), ep.Path, summary))
    }
    
    return strings.Join(lines, "\n")
}
`)
}

func renderSearchEndpointsGo(data templateData) string {
	return data.render(`package methods

import (
    "regexp"
    "sort"
    "strings"

    "` + "{{MODULE}}" + `/internal/spec"
)

type SearchQuery struct {
    Keyword     string
    Tag         string
    Method      string // lowercased http verb
    PathPattern string // regex
}

type EndpointSearchResult struct {
    ID      string   ` + "`json:\"id\"`" + `
    Method  string   ` + "`json:\"method\"`" + `
    Path    string   ` + "`json:\"path\"`" + `
    Summary string   ` + "`json:\"summary\"`" + `
    Tags    []string ` + "`json:\"tags\"`" + `
}

func SearchEndpoints(sm *spec.ServiceModel, q SearchQuery) []EndpointSearchResult {
    var re *regexp.Regexp
    if strings.TrimSpace(q.PathPattern) != "" {
        var err error
        re, err = regexp.Compile(q.PathPattern)
        if err != nil {
            // invalid pattern -> no matches
            return nil
        }
    }
    kw := strings.ToLower(strings.TrimSpace(q.Keyword))
    tag := strings.TrimSpace(q.Tag)
    method := strings.ToLower(strings.TrimSpace(q.Method))

    var out []EndpointSearchResult
    for _, ep := range sm.Endpoints {
        if method != "" && string(ep.Method) != method { continue }
        if tag != "" {
            found := false
            for _, t := range ep.Tags { if t == tag { found = true; break } }
            if !found { continue }
        }
        if re != nil && !re.MatchString(ep.Path) { continue }
        if kw != "" {
            text := strings.ToLower(ep.Summary + "\n" + ep.Description + "\n" + ep.Path)
            if !strings.Contains(text, kw) { continue }
        }
        out = append(out, EndpointSearchResult{ID: ep.ID, Method: string(ep.Method), Path: ep.Path, Summary: ep.Summary, Tags: append([]string(nil), ep.Tags...)})
    }
    sort.Slice(out, func(i, j int) bool {
        if out[i].Path == out[j].Path { return out[i].Method < out[j].Method }
        return out[i].Path < out[j].Path
    })
    return out
}
`)
}

func renderUtilsGo(data templateData) string {
	return data.render(`package methods

import (
    "encoding/json"
    "fmt"
    "strings"

    "{{MODULE}}/internal/spec"
)

// formatSchemaWithRefs recursively formats schema with reference resolution
func formatSchemaWithRefs(schema *spec.Schema, sm *spec.ServiceModel, indent string) []string {
    var lines []string
    
    if schema == nil {
        return lines
    }
    
    if schema.Type != "" {
        lines = append(lines, fmt.Sprintf("%s类型: %s", indent, schema.Type))
    }
    
    if len(schema.Properties) > 0 {
        lines = append(lines, fmt.Sprintf("%s属性:", indent))
        for propName, propSchema := range schema.Properties {
            isRequired := "[可选]"
            for _, req := range schema.Required {
                if req == propName {
                    isRequired = "[必需]"
                    break
                }
            }
            
            if propSchema.Schema != nil {
                // Direct schema
                propType := getStringOrDefault(propSchema.Schema.Type, "unknown")
                if propType == "array" {
                    // Handle array property with items
                    if propSchema.Schema.Items != nil && propSchema.Schema.Items.Ref != nil {
                        refName := strings.Replace(propSchema.Schema.Items.Ref.Ref, "#/components/schemas/", "", 1)
                        refName = strings.Replace(refName, "#/definitions/", "", 1)
                        lines = append(lines, fmt.Sprintf("%s  • %s: %s<%s> %s", indent, propName, propType, refName, isRequired))
                        
                        // Try to resolve the reference
                        if sm.Schemas != nil {
                            if refSchema, exists := sm.Schemas[refName]; exists {
                                lines = append(lines, fmt.Sprintf("%s    └─ %s 详情:", indent, refName))
                                refLines := formatSchemaWithRefs(&refSchema, sm, indent+"      ")
                                lines = append(lines, refLines...)
                            }
                        }
                    } else if propSchema.Schema.Items != nil && propSchema.Schema.Items.Schema != nil {
                        itemType := getStringOrDefault(propSchema.Schema.Items.Schema.Type, "unknown")
                        lines = append(lines, fmt.Sprintf("%s  • %s: %s<%s> %s", indent, propName, propType, itemType, isRequired))
                    } else {
                        lines = append(lines, fmt.Sprintf("%s  • %s: %s %s", indent, propName, propType, isRequired))
                    }
                } else {
                    lines = append(lines, fmt.Sprintf("%s  • %s: %s %s", indent, propName, propType, isRequired))
                }
                
                if len(propSchema.Schema.Enum) > 0 {
                    enumBytes, _ := json.Marshal(propSchema.Schema.Enum)
                    lines = append(lines, fmt.Sprintf("%s    允许值: %s", indent, string(enumBytes)))
                }
            } else if propSchema.Ref != nil {
                // Reference to another schema
                refName := strings.Replace(propSchema.Ref.Ref, "#/components/schemas/", "", 1)
                refName = strings.Replace(refName, "#/definitions/", "", 1)
                lines = append(lines, fmt.Sprintf("%s  • %s: %s (引用) %s", indent, propName, refName, isRequired))
                
                // Try to resolve the reference
                if sm.Schemas != nil {
                    if refSchema, exists := sm.Schemas[refName]; exists {
                        lines = append(lines, fmt.Sprintf("%s    └─ %s 详情:", indent, refName))
                        refLines := formatSchemaWithRefs(&refSchema, sm, indent+"      ")
                        lines = append(lines, refLines...)
                    }
                }
            } else {
                lines = append(lines, fmt.Sprintf("%s  • %s: unknown %s", indent, propName, isRequired))
            }
        }
    }
    
    if schema.Items != nil {
        if schema.Items.Schema != nil {
            itemType := getStringOrDefault(schema.Items.Schema.Type, "unknown")
            lines = append(lines, fmt.Sprintf("%s数组元素类型: %s", indent, itemType))
            itemLines := formatSchemaWithRefs(schema.Items.Schema, sm, indent+"  ")
            lines = append(lines, itemLines...)
        } else if schema.Items.Ref != nil {
            refName := strings.Replace(schema.Items.Ref.Ref, "#/components/schemas/", "", 1)
            refName = strings.Replace(refName, "#/definitions/", "", 1)
            lines = append(lines, fmt.Sprintf("%s数组元素类型: %s (引用)", indent, refName))
            
            // Try to resolve the reference
            if sm.Schemas != nil {
                if refSchema, exists := sm.Schemas[refName]; exists {
                    lines = append(lines, fmt.Sprintf("%s└─ %s 详情:", indent, refName))
                    refLines := formatSchemaWithRefs(&refSchema, sm, indent+"  ")
                    lines = append(lines, refLines...)
                }
            }
        }
    }
    
    if len(schema.AllOf) > 0 {
        lines = append(lines, fmt.Sprintf("%s组合类型 (AllOf):", indent))
        for i, subSchema := range schema.AllOf {
            lines = append(lines, fmt.Sprintf("%s  %d. ", indent, i+1))
            if subSchema.Schema != nil {
                subLines := formatSchemaWithRefs(subSchema.Schema, sm, indent+"    ")
                lines = append(lines, subLines...)
            } else if subSchema.Ref != nil {
                refName := strings.Replace(subSchema.Ref.Ref, "#/components/schemas/", "", 1)
                refName = strings.Replace(refName, "#/definitions/", "", 1)
                lines = append(lines, fmt.Sprintf("%s    引用: %s", indent, refName))
                if sm.Schemas != nil {
                    if refSchema, exists := sm.Schemas[refName]; exists {
                        refLines := formatSchemaWithRefs(&refSchema, sm, indent+"      ")
                        lines = append(lines, refLines...)
                    }
                }
            }
        }
    }
    
    if len(schema.Enum) > 0 {
        enumBytes, _ := json.Marshal(schema.Enum)
        lines = append(lines, fmt.Sprintf("%s允许值: %s", indent, string(enumBytes)))
    }
    
    return lines
}

func getStringOrDefault(s, def string) string {
    if strings.TrimSpace(s) == "" {
        return def
    }
    return s
}

func getTagsOrDefault(tags []string) string {
    if len(tags) == 0 {
        return "无"
    }
    return strings.Join(tags, ", ")
}
`)
}

func renderGetEndpointDetailsGo(data templateData) string {
	return data.render(`package methods

import (
    "encoding/json"
    "fmt"
    "strings"

    "` + "{{MODULE}}" + `/internal/spec"
)

func GetEndpointDetails(sm *spec.ServiceModel, idOrMethod string, pathOptional ...string) (*spec.EndpointModel, bool) {
    method := strings.ToLower(strings.TrimSpace(idOrMethod))
    if len(pathOptional) == 0 {
        // id is expected in form "<method> <path>"
        for _, ep := range sm.Endpoints {
            if ep.ID == idOrMethod { return &ep, true }
        }
        return nil, false
    }
    path := pathOptional[0]
    for _, ep := range sm.Endpoints {
        if string(ep.Method) == method && ep.Path == path { return &ep, true }
    }
    return nil, false
}

// FormatEndpointDetails formats endpoint details with schema reference resolution
func FormatEndpointDetails(ep *spec.EndpointModel, sm *spec.ServiceModel) string {
    var lines []string
    
    // Basic info
    lines = append(lines, fmt.Sprintf("%s %s", strings.ToUpper(string(ep.Method)), ep.Path))
    lines = append(lines, fmt.Sprintf("摘要: %s", getStringOrDefault(ep.Summary, "无")))
    lines = append(lines, fmt.Sprintf("描述: %s", getStringOrDefault(ep.Description, "无")))
    lines = append(lines, fmt.Sprintf("标签: %s", getTagsOrDefault(ep.Tags)))
    
    // Parameters
    if len(ep.Parameters) > 0 {
        lines = append(lines, "", "参数:")
        for _, param := range ep.Parameters {
            required := "[可选]"
            if param.Required {
                required = "[必需]"
            }
            paramType := "unknown"
            enumValues := ""
            if param.Schema != nil && param.Schema.Schema != nil {
                paramType = getStringOrDefault(param.Schema.Schema.Type, "unknown")
                if len(param.Schema.Schema.Enum) > 0 {
                    enumBytes, _ := json.Marshal(param.Schema.Schema.Enum)
                    enumValues = fmt.Sprintf(" (允许值: %s)", string(enumBytes))
                }
            }
            lines = append(lines, fmt.Sprintf("  • %s (%s) - %s%s %s", param.Name, param.In, paramType, enumValues, required))
        }
    }
    
    // Request body
    if ep.RequestBody != nil {
        lines = append(lines, "", "请求体:")
        required := "[可选]"
        if ep.RequestBody.Required {
            required = "[必需]"
        }
        
        contentTypes := make([]string, 0)
        for _, content := range ep.RequestBody.Content {
            contentTypes = append(contentTypes, content.Mime)
        }
        contentTypeStr := "unknown"
        if len(contentTypes) > 0 {
            contentTypeStr = strings.Join(contentTypes, ", ")
        }
        lines = append(lines, fmt.Sprintf("  Content-Type: %s %s", contentTypeStr, required))
        
        // Add request schema information
        for _, content := range ep.RequestBody.Content {
            if content.Schema != nil {
                lines = append(lines, fmt.Sprintf("  Schema (%s):", content.Mime))
                
                // Handle direct schema
                if content.Schema.Schema != nil {
                    schemaLines := formatSchemaWithRefs(content.Schema.Schema, sm, "    ")
                    lines = append(lines, schemaLines...)
                }
                
                // Handle schema reference
                if content.Schema.Ref != nil {
                    refName := strings.Replace(content.Schema.Ref.Ref, "#/components/schemas/", "", 1)
                    lines = append(lines, fmt.Sprintf("    引用: %s", refName))
                    
                    // Try to resolve the reference and show details
                    if sm.Schemas != nil {
                        if refSchema, exists := sm.Schemas[refName]; exists {
                            lines = append(lines, fmt.Sprintf("    └─ %s 详情:", refName))
                            refLines := formatSchemaWithRefs(&refSchema, sm, "      ")
                            lines = append(lines, refLines...)
                        }
                    }
                }
            }
            
            if content.Example != nil {
                exampleBytes, _ := json.Marshal(content.Example)
                lines = append(lines, fmt.Sprintf("  示例: %s", string(exampleBytes)))
            }
        }
    }
    
    // Responses
    if len(ep.Responses) > 0 {
        lines = append(lines, "", "响应:")
        for _, resp := range ep.Responses {
            lines = append(lines, fmt.Sprintf("  • %s: %s", resp.Status, resp.Description))
            
            // Add response schema information
            for _, content := range resp.Content {
                if content.Schema != nil {
                    lines = append(lines, fmt.Sprintf("    Schema (%s):", content.Mime))
                    
                    // Handle direct schema
                    if content.Schema.Schema != nil {
                        schemaLines := formatSchemaWithRefs(content.Schema.Schema, sm, "      ")
                        lines = append(lines, schemaLines...)
                    }
                    
                    // Handle schema reference
                    if content.Schema.Ref != nil {
                        refName := strings.Replace(content.Schema.Ref.Ref, "#/components/schemas/", "", 1)
                        lines = append(lines, fmt.Sprintf("      引用: %s", refName))
                        
                        // Try to resolve the reference and show details
                        if sm.Schemas != nil {
                            if refSchema, exists := sm.Schemas[refName]; exists {
                                lines = append(lines, fmt.Sprintf("      └─ %s 详情:", refName))
                                refLines := formatSchemaWithRefs(&refSchema, sm, "        ")
                                lines = append(lines, refLines...)
                            }
                        }
                    }
                }
                
                if content.Example != nil {
                    exampleBytes, _ := json.Marshal(content.Example)
                    lines = append(lines, fmt.Sprintf("    示例: %s", string(exampleBytes)))
                }
            }
        }
    }
    
    return strings.Join(lines, "\n")
}
`)
}

func renderListSchemasGo(data templateData) string {
	return data.render(`package methods

import (
    "sort"

    "` + "{{MODULE}}" + `/internal/spec"
)

type SchemaSummary struct {
    Name        string ` + "`json:\"name\"`" + `
    Description string ` + "`json:\"description\"`" + `
}

func ListSchemas(sm *spec.ServiceModel) []SchemaSummary {
    if len(sm.Schemas) == 0 { return nil }
    names := make([]string, 0, len(sm.Schemas))
    for name := range sm.Schemas { names = append(names, name) }
    sort.Strings(names)
    out := make([]SchemaSummary, 0, len(names))
    for _, name := range names {
        s := sm.Schemas[name]
        out = append(out, SchemaSummary{Name: name, Description: s.Description})
    }
    return out
}
`)
}

func renderGetSchemaDetailsGo(data templateData) string {
	return data.render(`package methods

import (
    "fmt"
    "strings"
    
    "` + "{{MODULE}}" + `/internal/spec"
)

func GetSchemaDetails(sm *spec.ServiceModel, name string) (*spec.Schema, bool) {
    s, ok := sm.Schemas[name]
    if !ok { return nil, false }
    // copy to avoid external mutation
    sc := s
    return &sc, true
}

// FormatSchemaDetails formats schema details with reference resolution
func FormatSchemaDetails(schema *spec.Schema, sm *spec.ServiceModel) string {
    var lines []string
    
    lines = append(lines, fmt.Sprintf("Schema: %s", schema.Name))
    
    if schema != nil {
        schemaLines := formatSchemaWithRefs(schema, sm, "")
        lines = append(lines, schemaLines...)
    }
    
    return strings.Join(lines, "\n")
}
`)
}

func renderGeneratedTests(data templateData) string {
	return data.render(`package tests

import (
    "testing"

    methods "` + "{{MODULE}}" + `/internal/mcp/methods"
    "` + "{{MODULE}}" + `/internal/spec"
)

func Test_ListAndSearch(t *testing.T) {
    sm, err := spec.Load()
    if err != nil { t.Fatalf("load: %v", err) }

    overview := methods.FormatEndpointsOverview(sm)
    if overview == "" { t.Fatalf("expected overview text, got empty") }

    // Use a more flexible search test - try a common keyword first
    searchKeywords := []string{"get", "list", "api", "user", "data"}
    var res []methods.EndpointSearchResult
    
    for _, keyword := range searchKeywords {
        res = methods.SearchEndpoints(sm, methods.SearchQuery{Keyword: keyword})
        if res != nil && len(res) > 0 {
            break
        }
    }
    
    if res == nil { t.Fatalf("expected a result list, got nil") }
}

func Test_SchemaDetails(t *testing.T) {
    sm, err := spec.Load()
    if err != nil { t.Fatalf("load: %v", err) }
    schemas := methods.ListSchemas(sm)
    if len(schemas) > 0 {
        if _, ok := methods.GetSchemaDetails(sm, schemas[0].Name); !ok {
            t.Fatalf("schema details not found")
        }
    } else {
        if _, ok := methods.GetSchemaDetails(sm, "__nonexistent__"); ok {
            t.Fatalf("unexpected schema found")
        }
    }
}
`)
}

// sampleSpecYAML is a small sample used for testdata in the generated project.
const sampleSpecYAML = "" +
	"openapi: 3.0.0\n" +
	"info:\n" +
	"  title: Sample\n" +
	"  version: '1.0.0'\n" +
	"paths:\n" +
	"  /pets:\n" +
	"    get:\n" +
	"      summary: List pets\n" +
	"      tags: [read]\n" +
	"      responses:\n" +
	"        '200':\n" +
	"          description: ok\n" +
	"          content:\n" +
	"            application/json:\n" +
	"              schema:\n" +
	"                type: array\n" +
	"                items:\n" +
	"                  type: string\n"
