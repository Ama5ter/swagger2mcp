package pyemitter

import (
	"bytes"
	"fmt"
	"strings"
	"text/template"

	genspec "github.com/mark3labs/swagger2mcp/internal/spec"
)

// TemplateData åŒ…å«æ‰€æœ‰æ¨¡æ¿éœ€è¦çš„å˜é‡
type TemplateData struct {
	ToolName     string                `json:"tool_name"`     // å·¥å…·åç§°
	PackageName  string                `json:"package_name"`  // PythonåŒ…å
	ServiceTitle string                `json:"service_title"` // æœåŠ¡æ ‡é¢˜
	ServiceModel *genspec.ServiceModel `json:"service_model"` // æœåŠ¡æ¨¡å‹
	Version      string                `json:"version"`       // ç‰ˆæœ¬å·
	Author       string                `json:"author"`        // ä½œè€…ä¿¡æ¯
}

// RenderTemplate æ¸²æŸ“æ¨¡æ¿å†…å®¹ï¼Œæ”¯æŒåŠ¨æ€å†…å®¹æ›¿æ¢
func RenderTemplate(templateContent string, data TemplateData) (string, error) {
	// åˆ›å»ºæ¨¡æ¿å‡½æ•°æ˜ å°„
	funcMap := template.FuncMap{
		"ToLower":    strings.ToLower,
		"ToUpper":    strings.ToUpper,
		"Title":      strings.Title,
		"Replace":    strings.ReplaceAll,
		"TrimSpace":  strings.TrimSpace,
		"Join":       strings.Join,
		"Split":      strings.Split,
		"Contains":   strings.Contains,
		"HasPrefix":  strings.HasPrefix,
		"HasSuffix":  strings.HasSuffix,
		"Indent":     indentLines,
		"Quote":      quoteString,
		"DocString":  formatDocString,
		"PythonName": toPythonName,
		"SafeString": toSafeString,
	}

	// è§£ææ¨¡æ¿
	tmpl, err := template.New("template").Funcs(funcMap).Parse(templateContent)
	if err != nil {
		return "", fmt.Errorf("è§£ææ¨¡æ¿å¤±è´¥: %w", err)
	}

	// æ‰§è¡Œæ¨¡æ¿æ¸²æŸ“
	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return "", fmt.Errorf("æ¸²æŸ“æ¨¡æ¿å¤±è´¥: %w", err)
	}

	return buf.String(), nil
}

// indentLines ä¸ºæ¯è¡Œæ·»åŠ æŒ‡å®šçš„ç¼©è¿›
func indentLines(indent string, text string) string {
	lines := strings.Split(text, "\n")
	result := make([]string, len(lines))
	for i, line := range lines {
		if strings.TrimSpace(line) != "" {
			result[i] = indent + line
		} else {
			result[i] = line
		}
	}
	return strings.Join(result, "\n")
}

// quoteString ä¸ºå­—ç¬¦ä¸²æ·»åŠ å¼•å·å¹¶è½¬ä¹‰ç‰¹æ®Šå­—ç¬¦
func quoteString(s string) string {
	return fmt.Sprintf("%q", s)
}

// formatDocString æ ¼å¼åŒ–Pythonæ–‡æ¡£å­—ç¬¦ä¸²
func formatDocString(text string) string {
	if strings.TrimSpace(text) == "" {
		return ""
	}

	lines := strings.Split(strings.TrimSpace(text), "\n")
	if len(lines) == 1 {
		return fmt.Sprintf(`"""%s"""`, lines[0])
	}

	var result []string
	result = append(result, `"""`)
	for _, line := range lines {
		result = append(result, line)
	}
	result = append(result, `"""`)

	return strings.Join(result, "\n")
}

// toPythonName å°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºæœ‰æ•ˆçš„Pythonæ ‡è¯†ç¬¦
func toPythonName(s string) string {
	// æ›¿æ¢ç‰¹æ®Šå­—ç¬¦ä¸ºä¸‹åˆ’çº¿
	s = strings.ReplaceAll(s, "-", "_")
	s = strings.ReplaceAll(s, " ", "_")
	s = strings.ReplaceAll(s, ".", "_")
	s = strings.ReplaceAll(s, "/", "_")

	// è½¬æ¢ä¸ºå°å†™
	s = strings.ToLower(s)

	// ç§»é™¤ä¸å…è®¸çš„å­—ç¬¦ï¼Œåªä¿ç•™å­—æ¯æ•°å­—å’Œä¸‹åˆ’çº¿
	var result strings.Builder
	for i, r := range s {
		if (r >= 'a' && r <= 'z') || (r >= '0' && r <= '9') || r == '_' {
			// ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸èƒ½æ˜¯æ•°å­—
			if i == 0 && r >= '0' && r <= '9' {
				result.WriteString("_")
			}
			result.WriteRune(r)
		}
	}

	name := result.String()
	if name == "" {
		return "unknown"
	}

	// å»é™¤å¼€å¤´å’Œç»“å°¾çš„ä¸‹åˆ’çº¿
	name = strings.Trim(name, "_")
	if name == "" {
		return "unknown"
	}

	return name
}

// toSafeString è½¬æ¢ä¸ºå®‰å…¨çš„å­—ç¬¦ä¸²ï¼ˆç”¨äºæ–‡ä»¶åç­‰ï¼‰
func toSafeString(s string) string {
	// æ›¿æ¢ç‰¹æ®Šå­—ç¬¦
	replacements := map[string]string{
		"<":  "lt",
		">":  "gt",
		"\"": "quote",
		"'":  "apos",
		"&":  "amp",
		"/":  "_",
		"\\": "_",
		":":  "_",
		"*":  "_",
		"?":  "_",
		"|":  "_",
	}

	result := s
	for old, new := range replacements {
		result = strings.ReplaceAll(result, old, new)
	}

	return result
}

// NewTemplateData åˆ›å»ºæ–°çš„æ¨¡æ¿æ•°æ®å®ä¾‹
func NewTemplateData(toolName, packageName string, sm *genspec.ServiceModel) TemplateData {
	return TemplateData{
		ToolName:     toolName,
		PackageName:  packageName,
		ServiceTitle: sm.Title,
		ServiceModel: sm,
		Version:      "0.1.0",
		Author:       "Generated by swagger2mcp",
	}
}

// æ¨¡æ¿æ¸²æŸ“é”™è¯¯ç±»å‹
type TemplateError struct {
	Template string
	Err      error
}

func (e *TemplateError) Error() string {
	return fmt.Sprintf("æ¨¡æ¿ %s æ¸²æŸ“å¤±è´¥: %v", e.Template, e.Err)
}

func (e *TemplateError) Unwrap() error {
	return e.Err
}

// RenderTemplateWithErrorHandling æ¸²æŸ“æ¨¡æ¿å¹¶æä¾›è¯¦ç»†é”™è¯¯å¤„ç†
func RenderTemplateWithErrorHandling(templateName, templateContent string, data TemplateData) (string, error) {
	result, err := RenderTemplate(templateContent, data)
	if err != nil {
		return "", &TemplateError{
			Template: templateName,
			Err:      err,
		}
	}
	return result, nil
}

// ValidateTemplateData éªŒè¯æ¨¡æ¿æ•°æ®çš„å®Œæ•´æ€§
func ValidateTemplateData(data TemplateData) error {
	if data.ToolName == "" {
		return fmt.Errorf("å·¥å…·åç§°ä¸èƒ½ä¸ºç©º")
	}
	if data.PackageName == "" {
		return fmt.Errorf("åŒ…åä¸èƒ½ä¸ºç©º")
	}
	if data.ServiceModel == nil {
		return fmt.Errorf("æœåŠ¡æ¨¡å‹ä¸èƒ½ä¸ºç©º")
	}
	if data.ServiceModel.Title == "" {
		return fmt.Errorf("æœåŠ¡æ ‡é¢˜ä¸èƒ½ä¸ºç©º")
	}
	return nil
}

// GetTemplateVariableNames è·å–æ¨¡æ¿ä¸­ä½¿ç”¨çš„å˜é‡ååˆ—è¡¨ï¼ˆç”¨äºè°ƒè¯•ï¼‰
func GetTemplateVariableNames() []string {
	return []string{
		"ToolName",
		"PackageName",
		"ServiceTitle",
		"ServiceModel",
		"Version",
		"Author",
	}
}

// GetTemplateFunctionNames è·å–å¯ç”¨çš„æ¨¡æ¿å‡½æ•°ååˆ—è¡¨ï¼ˆç”¨äºè°ƒè¯•ï¼‰
func GetTemplateFunctionNames() []string {
	return []string{
		"ToLower",
		"ToUpper",
		"Title",
		"Replace",
		"TrimSpace",
		"Join",
		"Split",
		"Contains",
		"HasPrefix",
		"HasSuffix",
		"Indent",
		"Quote",
		"DocString",
		"PythonName",
		"SafeString",
	}
}

// MainPyTemplate main.pyç¨‹åºå…¥å£ç‚¹æ¨¡æ¿
const MainPyTemplate = `#!/usr/bin/env python3
"""
{{.ServiceTitle}} MCP æœåŠ¡å™¨
é€šè¿‡æ ‡å‡†è¾“å…¥è¾“å‡ºæä¾› MCP (Model Context Protocol) æœåŠ¡

Generated by swagger2mcp
"""

import sys
import json
import logging
from typing import Dict, Any, Optional

from {{.PackageName}}.server import MCPServer


def setup_logging() -> None:
    """é…ç½®æ—¥å¿—ç³»ç»Ÿ"""
    logging.basicConfig(
        level=logging.WARNING,  # åªæ˜¾ç¤ºè­¦å‘Šå’Œé”™è¯¯ï¼Œé¿å…å¹²æ‰°MCPé€šä¿¡
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        handlers=[logging.StreamHandler(sys.stderr)]  # ä½¿ç”¨stderrï¼Œä¸å¹²æ‰°stdin/stdout
    )


def main() -> None:
    """MCPæœåŠ¡å™¨ä¸»å…¥å£ç‚¹"""
    try:
        # é…ç½®æ—¥å¿—
        setup_logging()
        logger = logging.getLogger(__name__)
        
        # åˆ›å»ºMCPæœåŠ¡å™¨å®ä¾‹
        server = MCPServer(tool_name="{{.ToolName}}")
        
        # å¯åŠ¨æ ‡å‡†è¾“å…¥è¾“å‡ºé€šä¿¡
        logger.info("å¯åŠ¨ {{.ServiceTitle}} MCP æœåŠ¡å™¨")
        server.run_stdio()
        
    except KeyboardInterrupt:
        # å¤„ç†Ctrl+Cä¼˜é›…é€€å‡º
        sys.exit(0)
    except Exception as e:
        logger = logging.getLogger(__name__)
        logger.error(f"MCPæœåŠ¡å™¨å¯åŠ¨å¤±è´¥: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()
`

// ServerPyTemplate server.py MCPæœåŠ¡å™¨æ ¸å¿ƒå®ç°æ¨¡æ¿
const ServerPyTemplate = `"""
MCP æœåŠ¡å™¨æ ¸å¿ƒå®ç°
å¤„ç† JSON-RPC 2.0 åè®®æ¶ˆæ¯ï¼Œæ”¯æŒæ ‡å‡† MCP æ–¹æ³•

Generated by swagger2mcp
"""

import sys
import json
import logging
from typing import Dict, Any, Optional, List, Union, Callable
from dataclasses import dataclass, asdict

from {{.PackageName}}.spec.loader import load_service_model
from {{.PackageName}}.mcp.methods import (
    list_endpoints,
    search_endpoints, 
    get_endpoint_details,
    list_schemas,
    get_schema_details
)


@dataclass
class JsonRpcError:
    """JSON-RPC 2.0 é”™è¯¯å¯¹è±¡"""
    code: int
    message: str
    data: Optional[Any] = None


@dataclass
class JsonRpcResponse:
    """JSON-RPC 2.0 å“åº”å¯¹è±¡"""
    jsonrpc: str = "2.0"
    id: Optional[Union[str, int]] = None
    result: Optional[Any] = None
    error: Optional[JsonRpcError] = None


class MCPServer:
    """MCP æœåŠ¡å™¨ä¸»ç±»ï¼Œå®ç° JSON-RPC 2.0 åè®®å¤„ç†"""
    
    # JSON-RPC 2.0 é”™è¯¯ä»£ç 
    PARSE_ERROR = -32700
    INVALID_REQUEST = -32600
    METHOD_NOT_FOUND = -32601
    INVALID_PARAMS = -32602
    INTERNAL_ERROR = -32603
    
    def __init__(self, tool_name: str):
        """
        åˆå§‹åŒ– MCP æœåŠ¡å™¨
        
        Args:
            tool_name: å·¥å…·åç§°
        """
        self.tool_name = tool_name
        self.logger = logging.getLogger(f"{__name__}.MCPServer")
        
        # åˆå§‹åŒ–çŠ¶æ€
        self.initialized = False
        
        try:
            # åŠ è½½æœåŠ¡æ¨¡å‹
            self.service_model = load_service_model()
            self.logger.info(f"æˆåŠŸåŠ è½½æœåŠ¡æ¨¡å‹: {self.service_model.title}")
            
            # æ³¨å†Œå·¥å…·æ–¹æ³•
            self.tools = self._register_tools()
            self.logger.info(f"æ³¨å†Œäº† {len(self.tools)} ä¸ªå·¥å…·æ–¹æ³•")
            
        except Exception as e:
            self.logger.error(f"åˆå§‹åŒ–å¤±è´¥: {e}")
            raise
    
    def _register_tools(self) -> Dict[str, Callable[..., Any]]:
        """æ³¨å†Œæ‰€æœ‰å¯ç”¨çš„å·¥å…·æ–¹æ³•"""
        return {
            "listEndpoints": self._handle_list_endpoints,
            "searchEndpoints": self._handle_search_endpoints,
            "getEndpointDetails": self._handle_get_endpoint_details,
            "listSchemas": self._handle_list_schemas,
            "getSchemaDetails": self._handle_get_schema_details,
        }
    
    def run_stdio(self) -> None:
        """å¯åŠ¨æ ‡å‡†è¾“å…¥è¾“å‡ºåè®®ç›‘å¬"""
        self.logger.info("å¼€å§‹ç›‘å¬æ ‡å‡†è¾“å…¥")
        
        try:
            for line in sys.stdin:
                line = line.strip()
                if not line:
                    continue
                
                response = self._process_message(line)
                if response:
                    # åªæœ‰è¯·æ±‚æ‰éœ€è¦å“åº”ï¼Œé€šçŸ¥æ¶ˆæ¯ä¸éœ€è¦å“åº”
                    self._send_response(response)
                    
        except EOFError:
            # æ ‡å‡†è¾“å…¥å…³é—­ï¼Œæ­£å¸¸é€€å‡º
            self.logger.info("æ ‡å‡†è¾“å…¥å·²å…³é—­ï¼ŒæœåŠ¡å™¨é€€å‡º")
        except Exception as e:
            self.logger.error(f"å¤„ç†æ ‡å‡†è¾“å…¥æ—¶å‘ç”Ÿé”™è¯¯: {e}")
            raise
    
    def _process_message(self, message: str) -> Optional[JsonRpcResponse]:
        """
        å¤„ç†æ¥æ”¶åˆ°çš„ JSON-RPC æ¶ˆæ¯
        
        Args:
            message: JSON-RPC æ¶ˆæ¯å­—ç¬¦ä¸²
            
        Returns:
            å“åº”å¯¹è±¡ï¼Œå¦‚æœæ˜¯é€šçŸ¥æ¶ˆæ¯åˆ™è¿”å›None
        """
        try:
            # è§£æJSONæ¶ˆæ¯
            try:
                data = json.loads(message)
            except json.JSONDecodeError as e:
                self.logger.warning(f"JSONè§£æå¤±è´¥: {e}")
                return JsonRpcResponse(
                    error=JsonRpcError(
                        code=self.PARSE_ERROR,
                        message="Parse error"
                    )
                )
            
            # éªŒè¯JSON-RPC 2.0æ ¼å¼
            if not isinstance(data, dict) or data.get("jsonrpc") != "2.0":
                return JsonRpcResponse(
                    id=data.get("id") if isinstance(data, dict) else None,
                    error=JsonRpcError(
                        code=self.INVALID_REQUEST,
                        message="Invalid Request"
                    )
                )
            
            method = data.get("method")
            params = data.get("params", {})
            msg_id = data.get("id")
            
            # å¦‚æœæ²¡æœ‰idå­—æ®µï¼Œè¿™æ˜¯ä¸€ä¸ªé€šçŸ¥æ¶ˆæ¯ï¼Œä¸éœ€è¦å“åº”
            if msg_id is None:
                self._handle_notification(method, params)
                return None
            
            # å¤„ç†è¯·æ±‚æ¶ˆæ¯
            return self._handle_request(method, params, msg_id)
            
        except Exception as e:
            self.logger.error(f"å¤„ç†æ¶ˆæ¯æ—¶å‘ç”Ÿå†…éƒ¨é”™è¯¯: {e}")
            return JsonRpcResponse(
                id=data.get("id") if "data" in locals() and isinstance(data, dict) else None,
                error=JsonRpcError(
                    code=self.INTERNAL_ERROR,
                    message="Internal error",
                    data=str(e)
                )
            )
    
    def _handle_notification(self, method: str, params: Dict[str, Any]) -> None:
        """å¤„ç†é€šçŸ¥æ¶ˆæ¯ï¼ˆæ— éœ€å“åº”ï¼‰.
        
        Args:
            method: é€šçŸ¥æ–¹æ³•å
            params: é€šçŸ¥å‚æ•°
        """
        self.logger.debug(f"æ”¶åˆ°é€šçŸ¥: {method}")
        # é€šçŸ¥æ¶ˆæ¯é€šå¸¸ç”¨äºå®¢æˆ·ç«¯å‘æœåŠ¡å™¨å‘é€çŠ¶æ€æ›´æ–°ç­‰ä¿¡æ¯
        # è¿™é‡Œå¯ä»¥æ ¹æ®éœ€è¦å¤„ç†ç‰¹å®šçš„é€šçŸ¥æ¶ˆæ¯
    
    def _handle_request(self, method: str, params: Dict[str, Any], msg_id: Union[str, int]) -> JsonRpcResponse:
        """
        å¤„ç†è¯·æ±‚æ¶ˆæ¯
        
        Args:
            method: æ–¹æ³•å
            params: å‚æ•°
            msg_id: æ¶ˆæ¯ID
            
        Returns:
            å“åº”å¯¹è±¡
        """
        try:
            # å¤„ç†æ ‡å‡†MCPæ–¹æ³•
            if method == "initialize":
                return self._handle_initialize(params, msg_id)
            elif method == "ping":
                return self._handle_ping(params, msg_id)
            elif method == "tools/list":
                return self._handle_tools_list(params, msg_id)
            elif method == "tools/call":
                return self._handle_tools_call(params, msg_id)
            else:
                return JsonRpcResponse(
                    id=msg_id,
                    error=JsonRpcError(
                        code=self.METHOD_NOT_FOUND,
                        message=f"Method not found: {method}"
                    )
                )
        except Exception as e:
            self.logger.error(f"å¤„ç†è¯·æ±‚ {method} æ—¶å‘ç”Ÿé”™è¯¯: {e}")
            return JsonRpcResponse(
                id=msg_id,
                error=JsonRpcError(
                    code=self.INTERNAL_ERROR,
                    message="Internal error",
                    data=str(e)
                )
            )
    
    def _handle_initialize(self, params: Dict[str, Any], msg_id: Union[str, int]) -> JsonRpcResponse:
        """å¤„ç†åˆå§‹åŒ–è¯·æ±‚.
        
        Args:
            params: åˆå§‹åŒ–å‚æ•°
            msg_id: æ¶ˆæ¯ID
            
        Returns:
            åŒ…å«æœåŠ¡å™¨èƒ½åŠ›ä¿¡æ¯çš„å“åº”å¯¹è±¡
        """
        self.initialized = True
        self.logger.info("MCPæœåŠ¡å™¨å·²åˆå§‹åŒ–")
        
        return JsonRpcResponse(
            id=msg_id,
            result={
                "protocolVersion": "2024-11-05",
                "capabilities": {
                    "tools": {}
                },
                "serverInfo": {
                    "name": self.tool_name,
                    "version": "1.0.0"
                }
            }
        )
    
    def _handle_ping(self, params: Dict[str, Any], msg_id: Union[str, int]) -> JsonRpcResponse:
        """å¤„ç†pingè¯·æ±‚.
        
        Args:
            params: pingå‚æ•°ï¼ˆé€šå¸¸ä¸ºç©ºï¼‰
            msg_id: æ¶ˆæ¯ID
            
        Returns:
            ç©ºç»“æœçš„å“åº”å¯¹è±¡
        """
        return JsonRpcResponse(
            id=msg_id,
            result={}
        )
    
    def _handle_tools_list(self, params: Dict[str, Any], msg_id: Union[str, int]) -> JsonRpcResponse:
        """å¤„ç†å·¥å…·åˆ—è¡¨è¯·æ±‚.
        
        Args:
            params: è¯·æ±‚å‚æ•°ï¼ˆé€šå¸¸ä¸ºç©ºï¼‰
            msg_id: æ¶ˆæ¯ID
            
        Returns:
            åŒ…å«æ‰€æœ‰å¯ç”¨å·¥å…·åˆ—è¡¨çš„å“åº”å¯¹è±¡
        """
        tools_list = []
        
        for tool_name in self.tools.keys():
            tool_info = {
                "name": tool_name,
                "description": self._get_tool_description(tool_name),
                "inputSchema": {
                    "type": "object",
                    "properties": self._get_tool_input_schema(tool_name),
                    "required": self._get_tool_required_params(tool_name)
                }
            }
            tools_list.append(tool_info)
        
        return JsonRpcResponse(
            id=msg_id,
            result={
                "tools": tools_list
            }
        )
    
    def _handle_tools_call(self, params: Dict[str, Any], msg_id: Union[str, int]) -> JsonRpcResponse:
        """å¤„ç†å·¥å…·è°ƒç”¨è¯·æ±‚.
        
        Args:
            params: å·¥å…·è°ƒç”¨å‚æ•°ï¼ŒåŒ…å«nameå’Œarguments
            msg_id: æ¶ˆæ¯ID
            
        Returns:
            åŒ…å«å·¥å…·æ‰§è¡Œç»“æœçš„å“åº”å¯¹è±¡
        """
        if not self.initialized:
            return JsonRpcResponse(
                id=msg_id,
                error=JsonRpcError(
                    code=self.INVALID_REQUEST,
                    message="Server not initialized"
                )
            )
        
        tool_name = params.get("name")
        arguments = params.get("arguments", {})
        
        if tool_name not in self.tools:
            return JsonRpcResponse(
                id=msg_id,
                error=JsonRpcError(
                    code=self.METHOD_NOT_FOUND,
                    message=f"Tool not found: {tool_name}"
                )
            )
        
        try:
            # è°ƒç”¨å…·ä½“çš„å·¥å…·å®ç°
            result = self.tools[tool_name](arguments)
            
            return JsonRpcResponse(
                id=msg_id,
                result={
                    "content": [
                        {
                            "type": "text",
                            "text": result
                        }
                    ]
                }
            )
            
        except Exception as e:
            self.logger.error(f"å·¥å…· {tool_name} æ‰§è¡Œå¤±è´¥: {e}")
            return JsonRpcResponse(
                id=msg_id,
                error=JsonRpcError(
                    code=self.INTERNAL_ERROR,
                    message=f"Tool execution failed: {str(e)}"
                )
            )
    
    def _send_response(self, response: JsonRpcResponse) -> None:
        """å‘é€å“åº”åˆ°æ ‡å‡†è¾“å‡º.
        
        Args:
            response: è¦å‘é€çš„JSON-RPCå“åº”å¯¹è±¡
        """
        try:
            # å°†å“åº”å¯¹è±¡è½¬æ¢ä¸ºå­—å…¸ï¼Œè¿‡æ»¤Noneå€¼
            response_dict = asdict(response)
            response_dict = {k: v for k, v in response_dict.items() if v is not None}
            
            # å¤„ç†åµŒå¥—çš„dataclasså¯¹è±¡
            if response.error:
                response_dict["error"] = asdict(response.error)
                response_dict["error"] = {k: v for k, v in response_dict["error"].items() if v is not None}
            
            # å‘é€JSONå“åº”
            json_response = json.dumps(response_dict, ensure_ascii=False)
            print(json_response, flush=True)
            
        except Exception as e:
            self.logger.error(f"å‘é€å“åº”å¤±è´¥: {e}")
    
    def _get_tool_description(self, tool_name: str) -> str:
        """è·å–å·¥å…·æè¿°.
        
        Args:
            tool_name: å·¥å…·åç§°
            
        Returns:
            å·¥å…·æè¿°æ–‡æœ¬
        """
        descriptions = {
            "listEndpoints": "åˆ—å‡ºæ‰€æœ‰å¯ç”¨çš„APIç«¯ç‚¹ï¼Œæä¾›ç«¯ç‚¹æ¦‚è§ˆå’Œç»Ÿè®¡ä¿¡æ¯",
            "searchEndpoints": "æ ¹æ®å…³é”®å­—ã€æ ‡ç­¾ã€æ–¹æ³•æˆ–è·¯å¾„æ¨¡å¼æœç´¢APIç«¯ç‚¹",
            "getEndpointDetails": "è·å–æŒ‡å®šAPIç«¯ç‚¹çš„è¯¦ç»†ä¿¡æ¯ï¼ŒåŒ…æ‹¬å‚æ•°ã€è¯·æ±‚ä½“å’Œå“åº”æ ¼å¼",
            "listSchemas": "åˆ—å‡ºæ‰€æœ‰å¯ç”¨çš„æ•°æ®æ¨¡å¼(Schema)å®šä¹‰",
            "getSchemaDetails": "è·å–æŒ‡å®šæ•°æ®æ¨¡å¼(Schema)çš„è¯¦ç»†å®šä¹‰ä¿¡æ¯"
        }
        return descriptions.get(tool_name, "")
    
    def _get_tool_input_schema(self, tool_name: str) -> Dict[str, Any]:
        """è·å–å·¥å…·è¾“å…¥å‚æ•°æ¨¡å¼.
        
        Args:
            tool_name: å·¥å…·åç§°
            
        Returns:
            å·¥å…·è¾“å…¥å‚æ•°çš„JSON Schemaå®šä¹‰
        """
        schemas = {
            "listEndpoints": {},
            "searchEndpoints": {
                "keyword": {
                    "type": "string",
                    "description": "æœç´¢å…³é”®å­—ï¼Œåœ¨ç«¯ç‚¹è·¯å¾„ã€æè¿°å’Œæ‘˜è¦ä¸­æŸ¥æ‰¾"
                },
                "tag": {
                    "type": "string", 
                    "description": "æŒ‰æ ‡ç­¾è¿‡æ»¤ç«¯ç‚¹"
                },
                "method": {
                    "type": "string",
                    "description": "æŒ‰HTTPæ–¹æ³•è¿‡æ»¤ç«¯ç‚¹ (GET, POST, PUT, DELETEç­‰)"
                },
                "path_pattern": {
                    "type": "string",
                    "description": "è·¯å¾„æ­£åˆ™è¡¨è¾¾å¼æ¨¡å¼"
                }
            },
            "getEndpointDetails": {
                "endpoint_id": {
                    "type": "string",
                    "description": "ç«¯ç‚¹ID (method+pathæ ¼å¼ï¼Œå¦‚ 'GET /users') æˆ–è€…åˆ†åˆ«æä¾›methodå’Œpathå‚æ•°"
                },
                "method": {
                    "type": "string",
                    "description": "HTTPæ–¹æ³•ï¼Œä¸pathä¸€èµ·ä½¿ç”¨"
                },
                "path": {
                    "type": "string", 
                    "description": "APIè·¯å¾„ï¼Œä¸methodä¸€èµ·ä½¿ç”¨"
                }
            },
            "listSchemas": {},
            "getSchemaDetails": {
                "schema_name": {
                    "type": "string",
                    "description": "è¦æŸ¥è¯¢çš„Schemaåç§°"
                }
            }
        }
        return schemas.get(tool_name, {})
    
    def _get_tool_required_params(self, tool_name: str) -> List[str]:
        """è·å–å·¥å…·å¿…éœ€å‚æ•°åˆ—è¡¨.
        
        Args:
            tool_name: å·¥å…·åç§°
            
        Returns:
            å¿…éœ€å‚æ•°åç§°åˆ—è¡¨
        """
        required = {
            "listEndpoints": [],
            "searchEndpoints": [],
            "getEndpointDetails": [],  # endpoint_id æˆ– (method + path) è‡³å°‘éœ€è¦ä¸€ä¸ª
            "listSchemas": [],
            "getSchemaDetails": ["schema_name"]
        }
        return required.get(tool_name, [])
    
    # å·¥å…·æ–¹æ³•å®ç°
    def _handle_list_endpoints(self, arguments: Dict[str, Any]) -> str:
        """å¤„ç†listEndpointså·¥å…·è°ƒç”¨.
        
        Args:
            arguments: å·¥å…·å‚æ•°ï¼ˆæ­¤å·¥å…·æ— éœ€å‚æ•°ï¼‰
            
        Returns:
            æ ¼å¼åŒ–çš„ç«¯ç‚¹æ¦‚è§ˆæ–‡æœ¬
        """
        return list_endpoints.format_endpoints_overview(self.service_model)
    
    def _handle_search_endpoints(self, arguments: Dict[str, Any]) -> str:
        """å¤„ç†searchEndpointså·¥å…·è°ƒç”¨.
        
        Args:
            arguments: æœç´¢å‚æ•°ï¼ŒåŒ…å«keywordã€tagã€methodã€path_patternç­‰
            
        Returns:
            æ ¼å¼åŒ–çš„æœç´¢ç»“æœæ–‡æœ¬
        """
        keyword = arguments.get("keyword", "")
        tag = arguments.get("tag", "")
        method = arguments.get("method", "")
        path_pattern = arguments.get("path_pattern", "")
        
        search_params = {
            "keyword": keyword,
            "tag": tag,
            "method": method,
            "path_pattern": path_pattern
        }
        
        results = search_endpoints.search_endpoints(self.service_model, search_params)
        return search_endpoints.format_search_results(results, search_params)
    
    def _handle_get_endpoint_details(self, arguments: Dict[str, Any]) -> str:
        """å¤„ç†getEndpointDetailså·¥å…·è°ƒç”¨.
        
        Args:
            arguments: ç«¯ç‚¹æŸ¥è¯¢å‚æ•°ï¼Œæ”¯æŒendpoint_idæˆ–method+pathç»„åˆ
            
        Returns:
            æ ¼å¼åŒ–çš„ç«¯ç‚¹è¯¦ç»†ä¿¡æ¯æ–‡æœ¬
        """
        endpoint_id = arguments.get("endpoint_id", "")
        method = arguments.get("method", "")
        path = arguments.get("path", "")
        
        if endpoint_id:
            # ä½¿ç”¨endpoint_idæŸ¥æ‰¾
            endpoint, found = get_endpoint_details.get_endpoint_details(
                self.service_model, endpoint_id
            )
        elif method and path:
            # ä½¿ç”¨methodå’ŒpathæŸ¥æ‰¾
            endpoint, found = get_endpoint_details.get_endpoint_details(
                self.service_model, method, path
            )
        else:
            return "é”™è¯¯ï¼šå¿…é¡»æä¾› endpoint_id æˆ– (method + path) å‚æ•°"
        
        if not found:
            return f"æœªæ‰¾åˆ°ç«¯ç‚¹: {endpoint_id or f'{method} {path}'}"
        
        return get_endpoint_details.format_endpoint_details(endpoint, self.service_model)
    
    def _handle_list_schemas(self, arguments: Dict[str, Any]) -> str:
        """å¤„ç†listSchemaså·¥å…·è°ƒç”¨.
        
        Args:
            arguments: å·¥å…·å‚æ•°ï¼ˆæ­¤å·¥å…·æ— éœ€å‚æ•°ï¼‰
            
        Returns:
            æ ¼å¼åŒ–çš„Schemaåˆ—è¡¨æ–‡æœ¬
        """
        schemas = list_schemas.list_schemas(self.service_model)
        return list_schemas.format_schemas_list(schemas)
    
    def _handle_get_schema_details(self, arguments: Dict[str, Any]) -> str:
        """å¤„ç†getSchemaDetailså·¥å…·è°ƒç”¨.
        
        Args:
            arguments: SchemaæŸ¥è¯¢å‚æ•°ï¼Œå¿…é¡»åŒ…å«schema_name
            
        Returns:
            æ ¼å¼åŒ–çš„Schemaè¯¦ç»†ä¿¡æ¯æ–‡æœ¬
        """
        schema_name = arguments.get("schema_name", "")
        
        if not schema_name:
            return "é”™è¯¯ï¼šå¿…é¡»æä¾› schema_name å‚æ•°"
        
        schema, found = get_schema_details.get_schema_details(
            self.service_model, schema_name
        )
        
        if not found:
            return f"æœªæ‰¾åˆ°Schema: {schema_name}"
        
        return get_schema_details.format_schema_details(schema, self.service_model)
`

// MethodsInitPyTemplate methods/__init__.pyæ–¹æ³•å¯¼å‡ºæ¨¡æ¿
const MethodsInitPyTemplate = `"""
MCP å·¥å…·æ–¹æ³•å®ç°åŒ…
æä¾›æ‰€æœ‰ API æŸ¥è¯¢å’Œæ–‡æ¡£åŠŸèƒ½

Generated by swagger2mcp  
"""

from .list_endpoints import format_endpoints_overview
from .search_endpoints import search_endpoints, format_search_results
from .get_endpoint_details import get_endpoint_details, format_endpoint_details
from .list_schemas import list_schemas, format_schemas_list
from .get_schema_details import get_schema_details, format_schema_details

__all__ = [
    'format_endpoints_overview',
    'search_endpoints',
    'format_search_results',
    'get_endpoint_details', 
    'format_endpoint_details',
    'list_schemas',
    'format_schemas_list',
    'get_schema_details',
    'format_schema_details'
]
`

// ListEndpointsPyTemplate list_endpoints.pyæ¨¡æ¿
const ListEndpointsPyTemplate = `"""
åˆ—å‡ºæ‰€æœ‰APIç«¯ç‚¹çš„å®ç°
æä¾›ç«¯ç‚¹æ¦‚è§ˆã€ç»Ÿè®¡ä¿¡æ¯å’Œæ ¼å¼åŒ–æ˜¾ç¤º

Generated by swagger2mcp
"""

from typing import List, Dict, Any, Counter
from {{.PackageName}}.spec.model import ServiceModel, EndpointModel


def format_endpoints_overview(service_model: ServiceModel) -> str:
    """
    æ ¼å¼åŒ–APIç«¯ç‚¹æ¦‚è§ˆä¿¡æ¯
    
    Args:
        service_model: æœåŠ¡æ¨¡å‹
        
    Returns:
        æ ¼å¼åŒ–çš„æ¦‚è§ˆæ–‡æœ¬
    """
    if not service_model or not service_model.endpoints:
        return "## ğŸ“‹ API æ¥å£æ¦‚è§ˆ\n\næš‚æ— å¯ç”¨çš„APIç«¯ç‚¹ã€‚"
    
    # ç»Ÿè®¡ä¿¡æ¯
    total_endpoints = len(service_model.endpoints)
    method_stats = {}
    tag_stats = {}
    
    for endpoint in service_model.endpoints:
        # ç»Ÿè®¡HTTPæ–¹æ³•
        method = endpoint.method.upper()
        method_stats[method] = method_stats.get(method, 0) + 1
        
        # ç»Ÿè®¡æ ‡ç­¾
        for tag in endpoint.tags:
            tag_stats[tag] = tag_stats.get(tag, 0) + 1
    
    # æ„å»ºæ¦‚è§ˆæ–‡æœ¬
    overview = []
    overview.append("## ğŸ“‹ API æ¥å£æ¦‚è§ˆ")
    overview.append("")
    overview.append(f"**æœåŠ¡åç§°**: {service_model.title}")
    overview.append(f"**ç‰ˆæœ¬**: {service_model.version}")
    
    if service_model.description:
        overview.append(f"**æè¿°**: {service_model.description}")
    
    # æœåŠ¡å™¨ä¿¡æ¯
    if service_model.servers:
        overview.append("")
        overview.append("### ğŸŒ æœåŠ¡å™¨")
        for i, server in enumerate(service_model.servers):
            overview.append(f"{i+1}. **{server.url}**")
            if server.description:
                overview.append(f"   - {server.description}")
    
    # ç»Ÿè®¡ä¿¡æ¯
    overview.append("")
    overview.append("### ğŸ“Š æ¥å£ç»Ÿè®¡")
    overview.append(f"**æ€»è®¡**: {total_endpoints} ä¸ªæ¥å£")
    
    # HTTPæ–¹æ³•ç»Ÿè®¡
    if method_stats:
        overview.append("")
        overview.append("**æŒ‰æ–¹æ³•åˆ†ç±»**:")
        for method, count in sorted(method_stats.items()):
            emoji = _get_method_emoji(method)
            overview.append(f"- {emoji} {method}: {count} ä¸ª")
    
    # æ ‡ç­¾ç»Ÿè®¡
    if tag_stats:
        overview.append("")
        overview.append("**æŒ‰æ ‡ç­¾åˆ†ç±»**:")
        for tag, count in sorted(tag_stats.items(), key=lambda x: x[1], reverse=True):
            overview.append(f"- ğŸ·ï¸ {tag}: {count} ä¸ª")
    
    # ç«¯ç‚¹åˆ—è¡¨
    overview.append("")
    overview.append("### ğŸ“ æ¥å£åˆ—è¡¨")
    overview.append("")
    
    # æŒ‰æ ‡ç­¾åˆ†ç»„æ˜¾ç¤ºç«¯ç‚¹
    endpoints_by_tag = {}
    untagged_endpoints = []
    
    for endpoint in service_model.endpoints:
        if endpoint.tags:
            for tag in endpoint.tags:
                if tag not in endpoints_by_tag:
                    endpoints_by_tag[tag] = []
                endpoints_by_tag[tag].append(endpoint)
        else:
            untagged_endpoints.append(endpoint)
    
    # æ˜¾ç¤ºæœ‰æ ‡ç­¾çš„ç«¯ç‚¹
    for tag in sorted(endpoints_by_tag.keys()):
        overview.append(f"#### ğŸ·ï¸ {tag}")
        overview.append("")
        endpoints = endpoints_by_tag[tag]
        for endpoint in sorted(endpoints, key=lambda e: (e.method, e.path)):
            overview.append(_format_endpoint_line(endpoint))
        overview.append("")
    
    # æ˜¾ç¤ºæ— æ ‡ç­¾çš„ç«¯ç‚¹
    if untagged_endpoints:
        overview.append("#### ğŸ“‚ å…¶ä»–æ¥å£")
        overview.append("")
        for endpoint in sorted(untagged_endpoints, key=lambda e: (e.method, e.path)):
            overview.append(_format_endpoint_line(endpoint))
        overview.append("")
    
    # Schemaä¿¡æ¯
    if service_model.schemas:
        overview.append("### ğŸ“‹ æ•°æ®æ¨¡å‹")
        overview.append(f"**å¯ç”¨Schema**: {len(service_model.schemas)} ä¸ª")
        schema_names = sorted(service_model.schemas.keys())[:10]  # åªæ˜¾ç¤ºå‰10ä¸ª
        for name in schema_names:
            overview.append(f"- ğŸ“„ {name}")
        if len(service_model.schemas) > 10:
            overview.append(f"- ... è¿˜æœ‰ {len(service_model.schemas) - 10} ä¸ª")
    
    overview.append("")
    overview.append("---")
    overview.append("ğŸ’¡ **æç¤º**: ä½¿ç”¨ ` + "`" + `searchEndpoints` + "`" + ` æœç´¢ç‰¹å®šæ¥å£ï¼Œä½¿ç”¨ ` + "`" + `getEndpointDetails` + "`" + ` æŸ¥çœ‹æ¥å£è¯¦æƒ…")
    
    return "\n".join(overview)


def _get_method_emoji(method: str) -> str:
    """è·å–HTTPæ–¹æ³•å¯¹åº”çš„emoji"""
    emojis = {
        "GET": "ğŸ”",
        "POST": "â•", 
        "PUT": "âœï¸",
        "PATCH": "ğŸ”§",
        "DELETE": "ğŸ—‘ï¸",
        "HEAD": "ğŸ‘ï¸",
        "OPTIONS": "âš™ï¸",
        "TRACE": "ğŸ”„"
    }
    return emojis.get(method.upper(), "ğŸ“¡")


def _format_endpoint_line(endpoint: EndpointModel) -> str:
    """æ ¼å¼åŒ–å•ä¸ªç«¯ç‚¹è¡Œ"""
    emoji = _get_method_emoji(endpoint.method)
    method = endpoint.method.upper()
    path = endpoint.path
    summary = endpoint.summary or "æ— æè¿°"
    
    # é™åˆ¶æ‘˜è¦é•¿åº¦
    if len(summary) > 50:
        summary = summary[:47] + "..."
    
    return f"- {emoji} **{method}** ` + "`" + `{path}` + "`" + ` - {summary}"
`

// SearchEndpointsPyTemplate search_endpoints.pyæ¨¡æ¿
const SearchEndpointsPyTemplate = `"""
æœç´¢APIç«¯ç‚¹çš„å®ç°
æ”¯æŒå…³é”®å­—ã€æ ‡ç­¾ã€æ–¹æ³•ã€è·¯å¾„æ¨¡å¼æœç´¢

Generated by swagger2mcp
"""

import re
from typing import List, Dict, Any, Optional
from {{.PackageName}}.spec.model import ServiceModel, EndpointModel


def search_endpoints(service_model: ServiceModel, search_params: Dict[str, str]) -> List[Dict[str, Any]]:
    """
    æœç´¢APIç«¯ç‚¹
    
    Args:
        service_model: æœåŠ¡æ¨¡å‹
        search_params: æœç´¢å‚æ•°ï¼ŒåŒ…å«keyword, tag, method, path_pattern
        
    Returns:
        åŒ¹é…çš„ç«¯ç‚¹åˆ—è¡¨ï¼Œæ¯ä¸ªç«¯ç‚¹åŒ…å«åŸºæœ¬ä¿¡æ¯
    """
    if not service_model or not service_model.endpoints:
        return []
    
    keyword = search_params.get("keyword", "").strip().lower()
    tag_filter = search_params.get("tag", "").strip().lower()
    method_filter = search_params.get("method", "").strip().lower()
    path_pattern = search_params.get("path_pattern", "").strip()
    
    results = []
    
    # ç¼–è¯‘æ­£åˆ™è¡¨è¾¾å¼ï¼ˆå¦‚æœæä¾›äº†è·¯å¾„æ¨¡å¼ï¼‰
    path_regex = None
    if path_pattern:
        try:
            path_regex = re.compile(path_pattern, re.IGNORECASE)
        except re.error:
            # å¦‚æœæ­£åˆ™è¡¨è¾¾å¼æ— æ•ˆï¼Œå°†å…¶ä½œä¸ºæ™®é€šå­—ç¬¦ä¸²å¤„ç†
            path_regex = None
            keyword = path_pattern.lower()
    
    for endpoint in service_model.endpoints:
        if _matches_filters(endpoint, keyword, tag_filter, method_filter, path_regex):
            results.append(_endpoint_to_dict(endpoint))
    
    return results


def _matches_filters(endpoint: EndpointModel, keyword: str, tag_filter: str, 
                    method_filter: str, path_regex: Optional[re.Pattern]) -> bool:
    """æ£€æŸ¥ç«¯ç‚¹æ˜¯å¦åŒ¹é…æœç´¢æ¡ä»¶"""
    
    # æ–¹æ³•è¿‡æ»¤
    if method_filter and endpoint.method.lower() != method_filter:
        return False
    
    # æ ‡ç­¾è¿‡æ»¤
    if tag_filter:
        tag_matches = any(tag_filter in tag.lower() for tag in endpoint.tags)
        if not tag_matches:
            return False
    
    # è·¯å¾„æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…
    if path_regex:
        if not path_regex.search(endpoint.path):
            return False
    
    # å…³é”®å­—æœç´¢ï¼ˆåœ¨è·¯å¾„ã€æ‘˜è¦ã€æè¿°ä¸­æŸ¥æ‰¾ï¼‰
    if keyword:
        search_text = " ".join([
            endpoint.path.lower(),
            endpoint.summary.lower() if endpoint.summary else "",
            endpoint.description.lower() if endpoint.description else "",
            " ".join(endpoint.tags).lower()
        ])
        
        if keyword not in search_text:
            return False
    
    return True


def _endpoint_to_dict(endpoint: EndpointModel) -> Dict[str, Any]:
    """å°†ç«¯ç‚¹æ¨¡å‹è½¬æ¢ä¸ºå­—å…¸æ ¼å¼"""
    return {
        "id": endpoint.id,
        "method": endpoint.method.upper(),
        "path": endpoint.path,
        "summary": endpoint.summary or "",
        "description": endpoint.description or "",
        "tags": endpoint.tags or [],
        "has_parameters": len(endpoint.parameters) > 0,
        "has_request_body": endpoint.request_body is not None,
        "has_responses": len(endpoint.responses) > 0
    }


def format_search_results(results: List[Dict[str, Any]], search_params: Dict[str, str]) -> str:
    """
    æ ¼å¼åŒ–æœç´¢ç»“æœ
    
    Args:
        results: æœç´¢ç»“æœåˆ—è¡¨
        search_params: æœç´¢å‚æ•°
        
    Returns:
        æ ¼å¼åŒ–çš„æœç´¢ç»“æœæ–‡æœ¬
    """
    if not results:
        return _format_no_results(search_params)
    
    output = []
    output.append("## ğŸ” æ¥å£æœç´¢ç»“æœ")
    output.append("")
    
    # æ˜¾ç¤ºæœç´¢æ¡ä»¶
    conditions = _format_search_conditions(search_params)
    if conditions:
        output.append(f"**æœç´¢æ¡ä»¶**: {conditions}")
        output.append("")
    
    output.append(f"**æ‰¾åˆ° {len(results)} ä¸ªåŒ¹é…çš„æ¥å£**")
    output.append("")
    
    # æŒ‰æ–¹æ³•åˆ†ç»„æ˜¾ç¤ºç»“æœ
    results_by_method = {}
    for result in results:
        method = result["method"]
        if method not in results_by_method:
            results_by_method[method] = []
        results_by_method[method].append(result)
    
    for method in sorted(results_by_method.keys()):
        endpoints = results_by_method[method]
        emoji = _get_method_emoji(method)
        output.append(f"### {emoji} {method} ({len(endpoints)} ä¸ª)")
        output.append("")
        
        for endpoint in sorted(endpoints, key=lambda e: e["path"]):
            output.append(_format_result_item(endpoint))
        output.append("")
    
    output.append("---")
    output.append("ğŸ’¡ **æç¤º**: ä½¿ç”¨ ` + "`" + `getEndpointDetails` + "`" + ` æŸ¥çœ‹æ¥å£è¯¦æƒ…")
    
    return "\n".join(output)


def _format_search_conditions(search_params: Dict[str, str]) -> str:
    """æ ¼å¼åŒ–æœç´¢æ¡ä»¶"""
    conditions = []
    
    if search_params.get("keyword"):
        conditions.append(f"å…³é”®å­—='{search_params['keyword']}'")
    if search_params.get("tag"):
        conditions.append(f"æ ‡ç­¾='{search_params['tag']}'")
    if search_params.get("method"):
        conditions.append(f"æ–¹æ³•={search_params['method'].upper()}")
    if search_params.get("path_pattern"):
        conditions.append(f"è·¯å¾„æ¨¡å¼='{search_params['path_pattern']}'")
    
    return ", ".join(conditions)


def _format_no_results(search_params: Dict[str, str]) -> str:
    """æ ¼å¼åŒ–æ— ç»“æœæ¶ˆæ¯"""
    conditions = _format_search_conditions(search_params)
    output = []
    output.append("## ğŸ” æ¥å£æœç´¢ç»“æœ")
    output.append("")
    
    if conditions:
        output.append(f"**æœç´¢æ¡ä»¶**: {conditions}")
        output.append("")
    
    output.append("âŒ **æœªæ‰¾åˆ°åŒ¹é…çš„æ¥å£**")
    output.append("")
    output.append("**å»ºè®®**:")
    output.append("- æ£€æŸ¥æœç´¢æ¡ä»¶æ˜¯å¦æ­£ç¡®")
    output.append("- å°è¯•ä½¿ç”¨æ›´å®½æ³›çš„å…³é”®å­—")
    output.append("- ä½¿ç”¨ ` + "`" + `listEndpoints` + "`" + ` æŸ¥çœ‹æ‰€æœ‰å¯ç”¨æ¥å£")
    
    return "\n".join(output)


def _format_result_item(endpoint: Dict[str, Any]) -> str:
    """æ ¼å¼åŒ–å•ä¸ªæœç´¢ç»“æœé¡¹"""
    path = endpoint["path"]
    summary = endpoint["summary"] or "æ— æè¿°"
    tags = endpoint["tags"]
    
    # é™åˆ¶æ‘˜è¦é•¿åº¦
    if len(summary) > 60:
        summary = summary[:57] + "..."
    
    result = f"- ` + "`" + `{path}` + "`" + ` - {summary}"
    
    # æ·»åŠ æ ‡ç­¾ä¿¡æ¯
    if tags:
        tag_str = ", ".join(tags[:3])  # æœ€å¤šæ˜¾ç¤º3ä¸ªæ ‡ç­¾
        if len(tags) > 3:
            tag_str += f" (+{len(tags)-3})"
        result += f" [ğŸ·ï¸ {tag_str}]"
    
    # æ·»åŠ åŠŸèƒ½æ ‡è¯†
    features = []
    if endpoint["has_parameters"]:
        features.append("ğŸ“å‚æ•°")
    if endpoint["has_request_body"]:  
        features.append("ğŸ“¤è¯·æ±‚ä½“")
    if endpoint["has_responses"]:
        features.append("ğŸ“¥å“åº”")
    
    if features:
        result += f" ({', '.join(features)})"
    
    return result


def _get_method_emoji(method: str) -> str:
    """è·å–HTTPæ–¹æ³•å¯¹åº”çš„emoji"""
    emojis = {
        "GET": "ğŸ”",
        "POST": "â•",
        "PUT": "âœï¸", 
        "PATCH": "ğŸ”§",
        "DELETE": "ğŸ—‘ï¸",
        "HEAD": "ğŸ‘ï¸",
        "OPTIONS": "âš™ï¸",
        "TRACE": "ğŸ”„"
    }
    return emojis.get(method.upper(), "ğŸ“¡")
`

// GetEndpointDetailsPyTemplate get_endpoint_details.pyæ¨¡æ¿
const GetEndpointDetailsPyTemplate = `"""
è·å–APIç«¯ç‚¹è¯¦ç»†ä¿¡æ¯çš„å®ç°
æ”¯æŒé€šè¿‡IDæˆ–method+pathæŸ¥æ‰¾ç«¯ç‚¹è¯¦æƒ…

Generated by swagger2mcp
"""

from typing import Tuple, Optional, List, Dict, Any
from {{.PackageName}}.spec.model import ServiceModel, EndpointModel, SchemaOrRef, ParameterModel, ResponseModel


def get_endpoint_details(service_model: ServiceModel, *args) -> Tuple[Optional[EndpointModel], bool]:
    """
    è·å–ç«¯ç‚¹è¯¦ç»†ä¿¡æ¯
    
    Args:
        service_model: æœåŠ¡æ¨¡å‹
        *args: å¯ä»¥æ˜¯ (endpoint_id,) æˆ– (method, path)
        
    Returns:
        (ç«¯ç‚¹æ¨¡å‹æˆ–None, æ˜¯å¦æ‰¾åˆ°)
    """
    if not service_model or not service_model.endpoints:
        return None, False
    
    if len(args) == 1:
        # é€šè¿‡endpoint_idæŸ¥æ‰¾
        endpoint_id = args[0].strip()
        for endpoint in service_model.endpoints:
            if endpoint.id == endpoint_id:
                return endpoint, True
    elif len(args) == 2:
        # é€šè¿‡methodå’ŒpathæŸ¥æ‰¾
        method = args[0].strip().lower()
        path = args[1].strip()
        for endpoint in service_model.endpoints:
            if endpoint.method.lower() == method and endpoint.path == path:
                return endpoint, True
    
    return None, False


def format_endpoint_details(endpoint: EndpointModel, service_model: ServiceModel) -> str:
    """
    æ ¼å¼åŒ–ç«¯ç‚¹è¯¦ç»†ä¿¡æ¯
    
    Args:
        endpoint: ç«¯ç‚¹æ¨¡å‹
        service_model: æœåŠ¡æ¨¡å‹ï¼ˆç”¨äºè§£æSchemaå¼•ç”¨ï¼‰
        
    Returns:
        æ ¼å¼åŒ–çš„è¯¦ç»†ä¿¡æ¯æ–‡æœ¬
    """
    output = []
    
    # æ ‡é¢˜å’ŒåŸºæœ¬ä¿¡æ¯
    emoji = _get_method_emoji(endpoint.method)
    method = endpoint.method.upper()
    output.append(f"## {emoji} {method} {endpoint.path}")
    output.append("")
    
    if endpoint.summary:
        output.append(f"**æ‘˜è¦**: {endpoint.summary}")
    
    if endpoint.description:
        output.append(f"**æè¿°**: {endpoint.description}")
        
    # æ ‡ç­¾
    if endpoint.tags:
        tags_str = " ".join([f"` + "`" + `{tag}` + "`" + `" for tag in endpoint.tags])
        output.append(f"**æ ‡ç­¾**: {tags_str}")
    
    output.append(f"**ç«¯ç‚¹ID**: ` + "`" + `{endpoint.id}` + "`" + `")
    output.append("")
    
    # å‚æ•°
    if endpoint.parameters:
        output.append("### ğŸ“ è¯·æ±‚å‚æ•°")
        output.append("")
        output.extend(_format_parameters(endpoint.parameters, service_model))
        output.append("")
    
    # è¯·æ±‚ä½“
    if endpoint.request_body:
        output.append("### ğŸ“¤ è¯·æ±‚ä½“")
        output.append("")
        output.extend(_format_request_body(endpoint.request_body, service_model))
        output.append("")
    
    # å“åº”
    if endpoint.responses:
        output.append("### ğŸ“¥ å“åº”")
        output.append("")
        output.extend(_format_responses(endpoint.responses, service_model))
        output.append("")
    
    output.append("---")
    output.append("ğŸ’¡ **æç¤º**: ä½¿ç”¨ ` + "`" + `listSchemas` + "`" + ` æŸ¥çœ‹å¯ç”¨çš„æ•°æ®æ¨¡å‹")
    
    return "\n".join(output)


def _format_parameters(parameters: List[ParameterModel], service_model: ServiceModel) -> List[str]:
    """æ ¼å¼åŒ–å‚æ•°åˆ—è¡¨"""
    output = []
    
    # æŒ‰ä½ç½®åˆ†ç»„
    params_by_location = {}
    for param in parameters:
        location = param.in_
        if location not in params_by_location:
            params_by_location[location] = []
        params_by_location[location].append(param)
    
    # æŒ‰ä½ç½®é¡ºåºæ˜¾ç¤º
    location_order = ["path", "query", "header", "cookie"]
    location_names = {
        "path": "ğŸ›¤ï¸ è·¯å¾„å‚æ•°",
        "query": "â“ æŸ¥è¯¢å‚æ•°", 
        "header": "ğŸ“‹ è¯·æ±‚å¤´å‚æ•°",
        "cookie": "ğŸª Cookieå‚æ•°"
    }
    
    for location in location_order:
        if location in params_by_location:
            params = params_by_location[location]
            output.append(f"#### {location_names[location]}")
            output.append("")
            
            for param in params:
                required_indicator = " *(å¿…éœ€)*" if param.required else " *(å¯é€‰)*"
                output.append(f"- **{param.name}**{required_indicator}")
                
                if param.schema:
                    schema_info = _format_schema_info(param.schema, service_model)
                    if schema_info:
                        output.append(f"  - {schema_info}")
                
                output.append("")
    
    return output


def _format_request_body(request_body, service_model: ServiceModel) -> List[str]:
    """æ ¼å¼åŒ–è¯·æ±‚ä½“ä¿¡æ¯"""
    output = []
    
    required_text = "**å¿…éœ€**" if request_body.required else "**å¯é€‰**"
    output.append(f"**æ˜¯å¦å¿…éœ€**: {required_text}")
    output.append("")
    
    if request_body.content:
        output.append("**æ”¯æŒçš„å†…å®¹ç±»å‹**:")
        output.append("")
        
        for i, media in enumerate(request_body.content):
            output.append(f"{i+1}. **{media.mime}**")
            
            if media.schema:
                schema_info = _format_schema_info(media.schema, service_model)
                if schema_info:
                    output.append(f"   - {schema_info}")
            
            if media.example is not None:
                output.append(f"   - ç¤ºä¾‹: ` + "`" + `{_format_example(media.example)}` + "`" + `")
            
            output.append("")
    
    return output


def _format_responses(responses: List[ResponseModel], service_model: ServiceModel) -> List[str]:
    """æ ¼å¼åŒ–å“åº”ä¿¡æ¯"""
    output = []
    
    for response in sorted(responses, key=lambda r: r.status):
        status_emoji = _get_status_emoji(response.status)
        output.append(f"#### {status_emoji} {response.status}")
        output.append("")
        
        if response.description:
            output.append(f"**æè¿°**: {response.description}")
            output.append("")
        
        if response.content:
            output.append("**å“åº”å†…å®¹**:")
            output.append("")
            
            for i, media in enumerate(response.content):
                output.append(f"{i+1}. **{media.mime}**")
                
                if media.schema:
                    schema_info = _format_schema_info(media.schema, service_model)
                    if schema_info:
                        output.append(f"   - {schema_info}")
                
                if media.example is not None:
                    output.append(f"   - ç¤ºä¾‹: ` + "`" + `{_format_example(media.example)}` + "`" + `")
                
                output.append("")
        
        output.append("")
    
    return output


def _format_schema_info(schema_or_ref: SchemaOrRef, service_model: ServiceModel) -> str:
    """æ ¼å¼åŒ–Schemaä¿¡æ¯"""
    if schema_or_ref.ref:
        # è¿™æ˜¯ä¸€ä¸ªå¼•ç”¨
        ref_name = schema_or_ref.ref.ref.replace("#/components/schemas/", "")
        if ref_name in service_model.schemas:
            schema = service_model.schemas[ref_name]
            return f"ç±»å‹: ` + "`" + `{schema.type or 'object'}` + "`" + ` (å¼•ç”¨: {ref_name})"
        else:
            return f"ç±»å‹: å¼•ç”¨ {ref_name} (æœªæ‰¾åˆ°å®šä¹‰)"
    elif schema_or_ref.schema:
        # ç›´æ¥çš„Schemaå®šä¹‰
        schema = schema_or_ref.schema
        schema_type = schema.type or "unknown"
        
        info_parts = [f"ç±»å‹: ` + "`" + `{schema_type}` + "`" + `"]
        
        if schema.format:
            info_parts.append(f"æ ¼å¼: ` + "`" + `{schema.format}` + "`" + `")
        
        if schema.enum:
            enum_values = ", ".join([str(v) for v in schema.enum[:3]])
            if len(schema.enum) > 3:
                enum_values += f" (+{len(schema.enum)-3})"
            info_parts.append(f"æšä¸¾: {enum_values}")
        
        if schema.description:
            desc = schema.description
            if len(desc) > 50:
                desc = desc[:47] + "..."
            info_parts.append(f"è¯´æ˜: {desc}")
        
        return " | ".join(info_parts)
    
    return "ç±»å‹: æœªçŸ¥"


def _format_example(example: Any) -> str:
    """æ ¼å¼åŒ–ç¤ºä¾‹å€¼"""
    if example is None:
        return "null"
    elif isinstance(example, str):
        return f'"{example}"' if len(str(example)) < 50 else f'"{str(example)[:47]}..."'
    elif isinstance(example, (dict, list)):
        example_str = str(example)
        return example_str if len(example_str) < 100 else f"{example_str[:97]}..."
    else:
        return str(example)


def _get_method_emoji(method: str) -> str:
    """è·å–HTTPæ–¹æ³•å¯¹åº”çš„emoji"""
    emojis = {
        "GET": "ğŸ”",
        "POST": "â•",
        "PUT": "âœï¸",
        "PATCH": "ğŸ”§", 
        "DELETE": "ğŸ—‘ï¸",
        "HEAD": "ğŸ‘ï¸",
        "OPTIONS": "âš™ï¸",
        "TRACE": "ğŸ”„"
    }
    return emojis.get(method.upper(), "ğŸ“¡")


def _get_status_emoji(status: str) -> str:
    """è·å–HTTPçŠ¶æ€ç å¯¹åº”çš„emoji"""
    if status.startswith("2"):
        return "âœ…"
    elif status.startswith("3"):
        return "ğŸ”„"
    elif status.startswith("4"):
        return "âŒ"
    elif status.startswith("5"):
        return "ğŸ’¥"
    else:
        return "ğŸ“¡"
`

// ListSchemasPyTemplate list_schemas.pyæ¨¡æ¿
const ListSchemasPyTemplate = `"""
åˆ—å‡ºæ•°æ®æ¨¡å¼(Schema)çš„å®ç°
æä¾›Schemaæ‘˜è¦ä¿¡æ¯å’Œåˆ—è¡¨æ˜¾ç¤º

Generated by swagger2mcp
"""

from typing import List, Dict, Any
from {{.PackageName}}.spec.model import ServiceModel, Schema


def list_schemas(service_model: ServiceModel) -> List[Dict[str, Any]]:
    """
    è·å–æ‰€æœ‰Schemaçš„æ‘˜è¦ä¿¡æ¯
    
    Args:
        service_model: æœåŠ¡æ¨¡å‹
        
    Returns:
        Schemaä¿¡æ¯åˆ—è¡¨
    """
    if not service_model or not service_model.schemas:
        return []
    
    schemas = []
    for name, schema in service_model.schemas.items():
        schema_info = {
            "name": name,
            "type": schema.type or "object",
            "description": schema.description or "",
            "has_properties": bool(schema.properties),
            "property_count": len(schema.properties) if schema.properties else 0,
            "has_enum": bool(schema.enum),
            "enum_count": len(schema.enum) if schema.enum else 0,
            "has_example": schema.example is not None,
            "format": schema.format or "",
            "required_fields": len(schema.required) if schema.required else 0
        }
        schemas.append(schema_info)
    
    # æŒ‰åç§°æ’åº
    return sorted(schemas, key=lambda s: s["name"])


def format_schemas_list(schemas: List[Dict[str, Any]]) -> str:
    """
    æ ¼å¼åŒ–Schemaåˆ—è¡¨æ˜¾ç¤º
    
    Args:
        schemas: Schemaä¿¡æ¯åˆ—è¡¨
        
    Returns:
        æ ¼å¼åŒ–çš„Schemaåˆ—è¡¨æ–‡æœ¬
    """
    if not schemas:
        return "## ğŸ“‹ æ•°æ®æ¨¡å‹åˆ—è¡¨\n\nâŒ **æš‚æ— å¯ç”¨çš„æ•°æ®æ¨¡å‹å®šä¹‰**"
    
    output = []
    output.append("## ğŸ“‹ æ•°æ®æ¨¡å‹ (Schema) åˆ—è¡¨")
    output.append("")
    output.append(f"**æ€»è®¡**: {len(schemas)} ä¸ªæ•°æ®æ¨¡å‹")
    output.append("")
    
    # æŒ‰ç±»å‹åˆ†ç»„ç»Ÿè®¡
    type_stats = {}
    for schema in schemas:
        schema_type = schema["type"]
        type_stats[schema_type] = type_stats.get(schema_type, 0) + 1
    
    if len(type_stats) > 1:
        output.append("**æŒ‰ç±»å‹åˆ†ç±»**:")
        for schema_type, count in sorted(type_stats.items()):
            emoji = _get_type_emoji(schema_type)
            output.append(f"- {emoji} {schema_type}: {count} ä¸ª")
        output.append("")
    
    # è¯¦ç»†åˆ—è¡¨
    output.append("### ğŸ“ è¯¦ç»†åˆ—è¡¨")
    output.append("")
    
    # æŒ‰ç±»å‹åˆ†ç»„æ˜¾ç¤º
    schemas_by_type = {}
    for schema in schemas:
        schema_type = schema["type"]
        if schema_type not in schemas_by_type:
            schemas_by_type[schema_type] = []
        schemas_by_type[schema_type].append(schema)
    
    for schema_type in sorted(schemas_by_type.keys()):
        type_schemas = schemas_by_type[schema_type]
        emoji = _get_type_emoji(schema_type)
        
        output.append(f"#### {emoji} {schema_type.title()} ç±»å‹ ({len(type_schemas)} ä¸ª)")
        output.append("")
        
        for schema in sorted(type_schemas, key=lambda s: s["name"]):
            output.append(_format_schema_item(schema))
        output.append("")
    
    output.append("---")
    output.append("ğŸ’¡ **æç¤º**: ä½¿ç”¨ ` + "`" + `getSchemaDetails` + "`" + ` æŸ¥çœ‹å…·ä½“Schemaçš„è¯¦ç»†å®šä¹‰")
    
    return "\n".join(output)


def _format_schema_item(schema: Dict[str, Any]) -> str:
    """æ ¼å¼åŒ–å•ä¸ªSchemaé¡¹ç›®"""
    name = schema["name"]
    description = schema["description"]
    
    # åŸºæœ¬ä¿¡æ¯
    result = f"- **{name}**"
    
    # æè¿°
    if description:
        desc = description
        if len(desc) > 60:
            desc = desc[:57] + "..."
        result += f" - {desc}"
    
    # å±æ€§ç»Ÿè®¡
    details = []
    
    if schema["has_properties"] and schema["property_count"] > 0:
        details.append(f"{schema['property_count']} å±æ€§")
    
    if schema["required_fields"] > 0:
        details.append(f"{schema['required_fields']} å¿…éœ€")
    
    if schema["has_enum"]:
        details.append(f"{schema['enum_count']} æšä¸¾å€¼")
    
    if schema["format"]:
        details.append(f"æ ¼å¼: {schema['format']}")
    
    if schema["has_example"]:
        details.append("æœ‰ç¤ºä¾‹")
    
    if details:
        result += f" [{', '.join(details)}]"
    
    return result


def _get_type_emoji(schema_type: str) -> str:
    """è·å–Schemaç±»å‹å¯¹åº”çš„emoji"""
    emojis = {
        "object": "ğŸ“¦",
        "array": "ğŸ“‹",
        "string": "ğŸ“",
        "number": "ğŸ”¢",
        "integer": "ğŸ”¢",
        "boolean": "â˜‘ï¸",
        "null": "âš«"
    }
    return emojis.get(schema_type.lower(), "ğŸ“„")
`

// GetSchemaDetailsPyTemplate get_schema_details.pyæ¨¡æ¿
const GetSchemaDetailsPyTemplate = `"""
è·å–æ•°æ®æ¨¡å¼(Schema)è¯¦ç»†ä¿¡æ¯çš„å®ç°  
æ”¯æŒé€’å½’è§£æSchemaå¼•ç”¨å’Œå¤æ‚ç»“æ„

Generated by swagger2mcp
"""

from typing import Tuple, Optional, List, Dict, Any, Set
from {{.PackageName}}.spec.model import ServiceModel, Schema, SchemaOrRef


def get_schema_details(service_model: ServiceModel, schema_name: str) -> Tuple[Optional[Schema], bool]:
    """
    è·å–æŒ‡å®šSchemaçš„è¯¦ç»†ä¿¡æ¯
    
    Args:
        service_model: æœåŠ¡æ¨¡å‹
        schema_name: Schemaåç§°
        
    Returns:
        (Schemaå¯¹è±¡æˆ–None, æ˜¯å¦æ‰¾åˆ°)
    """
    if not service_model or not service_model.schemas:
        return None, False
    
    schema_name = schema_name.strip()
    if schema_name in service_model.schemas:
        return service_model.schemas[schema_name], True
    
    return None, False


def format_schema_details(schema: Schema, service_model: ServiceModel) -> str:
    """
    æ ¼å¼åŒ–Schemaè¯¦ç»†ä¿¡æ¯
    
    Args:
        schema: Schemaå¯¹è±¡
        service_model: æœåŠ¡æ¨¡å‹ï¼ˆç”¨äºè§£æå¼•ç”¨ï¼‰
        
    Returns:
        æ ¼å¼åŒ–çš„è¯¦ç»†ä¿¡æ¯æ–‡æœ¬
    """
    output = []
    visited_refs = set()  # é¿å…å¾ªç¯å¼•ç”¨
    
    # æ ‡é¢˜å’ŒåŸºæœ¬ä¿¡æ¯
    emoji = _get_type_emoji(schema.type or "object")
    output.append(f"## {emoji} {schema.name}")
    output.append("")
    
    if schema.description:
        output.append(f"**æè¿°**: {schema.description}")
        output.append("")
    
    # åŸºæœ¬ç±»å‹ä¿¡æ¯
    output.append("### â„¹ï¸ åŸºæœ¬ä¿¡æ¯")
    output.append("")
    output.append(f"- **ç±»å‹**: ` + "`" + `{schema.type or 'object'}` + "`" + `")
    
    if schema.format:
        output.append(f"- **æ ¼å¼**: ` + "`" + `{schema.format}` + "`" + `")
    
    if schema.example is not None:
        output.append(f"- **ç¤ºä¾‹**: ` + "`" + `{_format_example(schema.example)}` + "`" + `")
    
    output.append("")
    
    # æšä¸¾å€¼
    if schema.enum:
        output.append("### ğŸ“ æšä¸¾å€¼")
        output.append("")
        for i, value in enumerate(schema.enum):
            output.append(f"{i+1}. ` + "`" + `{value}` + "`" + `")
        output.append("")
    
    # å±æ€§
    if schema.properties:
        output.append("### ğŸ“¦ å±æ€§")
        output.append("")
        output.extend(_format_properties(schema, service_model, visited_refs, level=0))
        output.append("")
    
    # æ•°ç»„é¡¹ç›®
    if schema.items:
        output.append("### ğŸ“‹ æ•°ç»„é¡¹ç›®ç±»å‹")
        output.append("")
        output.extend(_format_schema_or_ref(schema.items, service_model, visited_refs, level=0))
        output.append("")
    
    # ç»„åˆSchema (allOf, anyOf, oneOf)
    if schema.all_of:
        output.append("### ğŸ”— å…¨éƒ¨åŒ¹é… (allOf)")
        output.append("")
        output.extend(_format_schema_list(schema.all_of, service_model, visited_refs, level=0))
        output.append("")
    
    if schema.any_of:
        output.append("### ğŸ”€ ä»»ä¸€åŒ¹é… (anyOf)")
        output.append("")
        output.extend(_format_schema_list(schema.any_of, service_model, visited_refs, level=0))
        output.append("")
    
    if schema.one_of:
        output.append("### âš¡ å•ä¸€åŒ¹é… (oneOf)")
        output.append("")
        output.extend(_format_schema_list(schema.one_of, service_model, visited_refs, level=0))
        output.append("")
    
    output.append("---")
    output.append("ğŸ’¡ **æç¤º**: ä½¿ç”¨ ` + "`" + `listSchemas` + "`" + ` æŸ¥çœ‹æ‰€æœ‰å¯ç”¨çš„æ•°æ®æ¨¡å‹")
    
    return "\n".join(output)


def _format_properties(schema: Schema, service_model: ServiceModel, 
                      visited_refs: Set[str], level: int) -> List[str]:
    """æ ¼å¼åŒ–å±æ€§åˆ—è¡¨"""
    output = []
    
    if not schema.properties:
        return output
    
    required_fields = set(schema.required or [])
    
    for prop_name in sorted(schema.properties.keys()):
        prop_schema = schema.properties[prop_name]
        required_indicator = " *(å¿…éœ€)*" if prop_name in required_fields else " *(å¯é€‰)*"
        
        indent = "  " * level
        output.append(f"{indent}- **{prop_name}**{required_indicator}")
        
        # é€’å½’å¤„ç†å±æ€§Schema
        prop_details = _format_schema_or_ref(prop_schema, service_model, visited_refs, level + 1)
        output.extend([f"  {line}" for line in prop_details])
        
        output.append("")
    
    return output


def _format_schema_or_ref(schema_or_ref: SchemaOrRef, service_model: ServiceModel,
                         visited_refs: Set[str], level: int) -> List[str]:
    """æ ¼å¼åŒ–SchemaOrRefå¯¹è±¡"""
    output = []
    indent = "  " * level
    
    if schema_or_ref.ref:
        # å¤„ç†å¼•ç”¨
        ref_name = schema_or_ref.ref.ref.replace("#/components/schemas/", "")
        
        if ref_name in visited_refs:
            output.append(f"{indent}ğŸ“ å¼•ç”¨: ` + "`" + `{ref_name}` + "`" + ` *(å¾ªç¯å¼•ç”¨ï¼Œå·²è®¿é—®)*")
            return output
        
        if ref_name in service_model.schemas:
            visited_refs.add(ref_name)
            referenced_schema = service_model.schemas[ref_name]
            
            output.append(f"{indent}ğŸ“ å¼•ç”¨: ` + "`" + `{ref_name}` + "`" + ` ({referenced_schema.type or 'object'})")
            
            if referenced_schema.description:
                desc = referenced_schema.description
                if len(desc) > 80:
                    desc = desc[:77] + "..."
                output.append(f"{indent}  - {desc}")
            
            # å¦‚æœå¼•ç”¨çš„Schemaæœ‰å±æ€§ä¸”å±‚çº§ä¸å¤ªæ·±ï¼Œå±•ç¤ºä¸€äº›åŸºæœ¬ä¿¡æ¯
            if level < 2 and referenced_schema.properties:
                output.append(f"{indent}  - å±æ€§: {len(referenced_schema.properties)} ä¸ª")
                if referenced_schema.required:
                    output.append(f"{indent}  - å¿…éœ€: {len(referenced_schema.required)} ä¸ª")
            
            visited_refs.discard(ref_name)
        else:
            output.append(f"{indent}ğŸ“ å¼•ç”¨: ` + "`" + `{ref_name}` + "`" + ` *(æœªæ‰¾åˆ°å®šä¹‰)*")
            
    elif schema_or_ref.schema:
        # å¤„ç†ç›´æ¥Schemaå®šä¹‰
        schema = schema_or_ref.schema
        schema_type = schema.type or "object"
        
        type_info = f"{indent}ğŸ“„ ç±»å‹: ` + "`" + `{schema_type}` + "`" + `"
        if schema.format:
            type_info += f" (æ ¼å¼: ` + "`" + `{schema.format}` + "`" + `)"
        output.append(type_info)
        
        if schema.description:
            desc = schema.description
            if len(desc) > 80:
                desc = desc[:77] + "..."
            output.append(f"{indent}  - {desc}")
        
        if schema.example is not None:
            output.append(f"{indent}  - ç¤ºä¾‹: ` + "`" + `{_format_example(schema.example)}` + "`" + `")
        
        # é€’å½’å¤„ç†åµŒå¥—å±æ€§ï¼ˆä»…åœ¨å±‚çº§ä¸å¤ªæ·±æ—¶ï¼‰
        if level < 3 and schema.properties:
            output.append(f"{indent}  - å±æ€§:")
            nested_props = _format_properties(schema, service_model, visited_refs, level + 1)
            output.extend([f"  {line}" for line in nested_props])
        elif schema.properties:
            output.append(f"{indent}  - å±æ€§: {len(schema.properties)} ä¸ª")
        
        # å¤„ç†æ•°ç»„é¡¹ç›®
        if schema.items:
            output.append(f"{indent}  - æ•°ç»„é¡¹ç›®:")
            item_details = _format_schema_or_ref(schema.items, service_model, visited_refs, level + 1)
            output.extend([f"  {line}" for line in item_details])
        
        # å¤„ç†æšä¸¾
        if schema.enum:
            enum_values = ", ".join([str(v) for v in schema.enum[:5]])
            if len(schema.enum) > 5:
                enum_values += f" (+{len(schema.enum)-5})"
            output.append(f"{indent}  - æšä¸¾å€¼: {enum_values}")
    
    return output


def _format_schema_list(schema_list: List[SchemaOrRef], service_model: ServiceModel,
                       visited_refs: Set[str], level: int) -> List[str]:
    """æ ¼å¼åŒ–Schemaåˆ—è¡¨"""
    output = []
    
    for i, schema_or_ref in enumerate(schema_list):
        output.append(f"{i+1}.")
        schema_details = _format_schema_or_ref(schema_or_ref, service_model, visited_refs, level)
        output.extend([f"   {line}" for line in schema_details])
        output.append("")
    
    return output


def _format_example(example: Any) -> str:
    """æ ¼å¼åŒ–ç¤ºä¾‹å€¼"""
    if example is None:
        return "null"
    elif isinstance(example, str):
        return f'"{example}"' if len(str(example)) < 50 else f'"{str(example)[:47]}..."'
    elif isinstance(example, (dict, list)):
        example_str = str(example)
        return example_str if len(example_str) < 100 else f"{example_str[:97]}..."
    else:
        return str(example)


def _get_type_emoji(schema_type: str) -> str:
    """è·å–Schemaç±»å‹å¯¹åº”çš„emoji"""
    emojis = {
        "object": "ğŸ“¦",
        "array": "ğŸ“‹", 
        "string": "ğŸ“",
        "number": "ğŸ”¢",
        "integer": "ğŸ”¢",
        "boolean": "â˜‘ï¸",
        "null": "âš«"
    }
    return emojis.get(schema_type.lower(), "ğŸ“„")
`

// TestsInitPyTemplate tests/__init__.pyæµ‹è¯•åŒ…åˆå§‹åŒ–æ¨¡æ¿
const TestsInitPyTemplate = `"""
æµ‹è¯•åŒ…åˆå§‹åŒ–æ–‡ä»¶
ä¸º{{.ServiceTitle}} MCPæœåŠ¡å™¨æä¾›æµ‹è¯•åŠŸèƒ½

Generated by swagger2mcp
"""

# å¯¼å…¥å¸¸ç”¨æµ‹è¯•å·¥å…·å’Œé…ç½®
import sys
import os
from pathlib import Path

# ç¡®ä¿èƒ½å¤Ÿå¯¼å…¥æºä»£ç åŒ…
src_path = Path(__file__).parent.parent / "src"
if str(src_path) not in sys.path:
    sys.path.insert(0, str(src_path))

# æµ‹è¯•é…ç½®
TEST_DATA_DIR = Path(__file__).parent / "data"
TEMP_DIR = Path(__file__).parent / "temp"

# åˆ›å»ºæµ‹è¯•æ‰€éœ€çš„ç›®å½•
TEST_DATA_DIR.mkdir(exist_ok=True)
TEMP_DIR.mkdir(exist_ok=True)

__version__ = "1.0.0"
__author__ = "Generated by swagger2mcp"
`

// TestMCPMethodsPyTemplate tests/test_mcp_methods.py MCPæ–¹æ³•å•å…ƒæµ‹è¯•æ¨¡æ¿
const TestMCPMethodsPyTemplate = `"""
MCPå·¥å…·æ–¹æ³•çš„å•å…ƒæµ‹è¯•
æµ‹è¯•æ‰€æœ‰MCPæ–¹æ³•çš„åŸºæœ¬åŠŸèƒ½å’Œæ­£ç¡®æ€§

Generated by swagger2mcp
"""

import pytest
import json
from typing import Dict, List, Any, Optional
from unittest.mock import Mock, patch

# å¯¼å…¥è¢«æµ‹è¯•çš„æ¨¡å—
from {{.PackageName}}.spec.loader import load_service_model
from {{.PackageName}}.spec.model import ServiceModel
from {{.PackageName}}.mcp.methods import (
    list_endpoints, 
    search_endpoints, 
    get_endpoint_details, 
    list_schemas, 
    get_schema_details
)


class TestMCPMethods:
    """MCPæ–¹æ³•æµ‹è¯•ç±»"""
    
    @pytest.fixture(scope="class")
    def service_model(self) -> ServiceModel:
        """
        æä¾›æµ‹è¯•ç”¨çš„ServiceModelå®ä¾‹
        
        Returns:
            åŠ è½½çš„ServiceModelå¯¹è±¡
        """
        try:
            model = load_service_model()
            assert model is not None, "ServiceModelä¸èƒ½ä¸ºç©º"
            return model
        except Exception as e:
            pytest.fail(f"åŠ è½½ServiceModelå¤±è´¥: {e}")
    
    @pytest.fixture
    def mock_empty_service_model(self) -> ServiceModel:
        """
        æä¾›ç©ºçš„ServiceModelç”¨äºè¾¹ç•Œæµ‹è¯•
        
        Returns:
            ç©ºçš„ServiceModelå¯¹è±¡
        """
        from {{.PackageName}}.spec.model import ServiceModel
        return ServiceModel(
            title="Empty Test API",
            version="0.0.1", 
            description="ç”¨äºæµ‹è¯•çš„ç©ºAPI",
            servers=[],
            tags=[],
            endpoints=[],
            schemas={}
        )
    
    def test_load_service_model_success(self, service_model: ServiceModel):
        """æµ‹è¯•ServiceModelåŠ è½½æˆåŠŸ"""
        assert service_model is not None
        assert hasattr(service_model, 'title')
        assert hasattr(service_model, 'version')
        assert hasattr(service_model, 'endpoints')
        assert hasattr(service_model, 'schemas')
        print(f"âœ… æˆåŠŸåŠ è½½ServiceModel: {service_model.title} v{service_model.version}")
    
    def test_list_endpoints_overview(self, service_model: ServiceModel):
        """æµ‹è¯•ç«¯ç‚¹æ¦‚è§ˆåŠŸèƒ½"""
        overview = list_endpoints.format_endpoints_overview(service_model)
        
        # åŸºæœ¬éªŒè¯
        assert isinstance(overview, str), "è¿”å›ç»“æœåº”è¯¥æ˜¯å­—ç¬¦ä¸²"
        assert len(overview) > 0, "æ¦‚è§ˆå†…å®¹ä¸èƒ½ä¸ºç©º"
        assert "API æ¥å£æ¦‚è§ˆ" in overview, "åº”åŒ…å«æ ‡é¢˜"
        
        # å¦‚æœæœ‰ç«¯ç‚¹ï¼Œåº”è¯¥åŒ…å«ç»Ÿè®¡ä¿¡æ¯
        if service_model.endpoints:
            assert "æ€»è®¡" in overview, "åº”åŒ…å«ç«¯ç‚¹æ€»æ•°ç»Ÿè®¡"
            assert "æŒ‰æ–¹æ³•åˆ†ç±»" in overview or "æŒ‰æ ‡ç­¾åˆ†ç±»" in overview, "åº”åŒ…å«åˆ†ç±»ç»Ÿè®¡"
        
        print(f"âœ… ç«¯ç‚¹æ¦‚è§ˆç”ŸæˆæˆåŠŸï¼Œå†…å®¹é•¿åº¦: {len(overview)}")
    
    def test_list_endpoints_empty_model(self, mock_empty_service_model: ServiceModel):
        """æµ‹è¯•ç©ºæ¨¡å‹çš„ç«¯ç‚¹æ¦‚è§ˆ"""
        overview = list_endpoints.format_endpoints_overview(mock_empty_service_model)
        
        assert isinstance(overview, str)
        assert "æš‚æ— å¯ç”¨çš„APIç«¯ç‚¹" in overview
        print("âœ… ç©ºæ¨¡å‹ç«¯ç‚¹æ¦‚è§ˆå¤„ç†æ­£ç¡®")
    
    def test_search_endpoints_keyword(self, service_model: ServiceModel):
        """æµ‹è¯•å…³é”®å­—æœç´¢åŠŸèƒ½"""
        if not service_model.endpoints:
            pytest.skip("æ²¡æœ‰ç«¯ç‚¹æ•°æ®ï¼Œè·³è¿‡æœç´¢æµ‹è¯•")
        
        # æµ‹è¯•å…³é”®å­—æœç´¢
        search_params = {
            "keyword": "api", 
            "tag": "", 
            "method": "", 
            "path_pattern": ""
        }
        results = search_endpoints.search_endpoints(service_model, search_params)
        
        assert isinstance(results, list), "æœç´¢ç»“æœåº”è¯¥æ˜¯åˆ—è¡¨"
        
        # å¦‚æœæœ‰ç»“æœï¼ŒéªŒè¯ç»“æœç»“æ„
        if results:
            result = results[0]
            required_keys = ["id", "method", "path", "summary", "tags"]
            for key in required_keys:
                assert key in result, f"æœç´¢ç»“æœåº”åŒ…å«å­—æ®µ: {key}"
        
        # æµ‹è¯•æœç´¢ç»“æœæ ¼å¼åŒ–
        formatted = search_endpoints.format_search_results(results, search_params)
        assert isinstance(formatted, str)
        assert "æ¥å£æœç´¢ç»“æœ" in formatted
        
        print(f"âœ… å…³é”®å­—æœç´¢æµ‹è¯•é€šè¿‡ï¼Œæ‰¾åˆ° {len(results)} ä¸ªç»“æœ")
    
    def test_search_endpoints_by_method(self, service_model: ServiceModel):
        """æµ‹è¯•æŒ‰HTTPæ–¹æ³•æœç´¢"""
        if not service_model.endpoints:
            pytest.skip("æ²¡æœ‰ç«¯ç‚¹æ•°æ®ï¼Œè·³è¿‡æ–¹æ³•æœç´¢æµ‹è¯•")
        
        # è·å–ç¬¬ä¸€ä¸ªç«¯ç‚¹çš„æ–¹æ³•è¿›è¡Œæœç´¢
        first_method = service_model.endpoints[0].method.lower()
        search_params = {
            "keyword": "", 
            "tag": "", 
            "method": first_method, 
            "path_pattern": ""
        }
        
        results = search_endpoints.search_endpoints(service_model, search_params)
        assert isinstance(results, list)
        
        # éªŒè¯æ‰€æœ‰ç»“æœéƒ½æ˜¯æŒ‡å®šçš„HTTPæ–¹æ³•
        for result in results:
            assert result["method"].lower() == first_method.upper(), "æœç´¢ç»“æœæ–¹æ³•åº”åŒ¹é…"
        
        print(f"âœ… HTTPæ–¹æ³•æœç´¢æµ‹è¯•é€šè¿‡ï¼Œæ–¹æ³•: {first_method.upper()}")
    
    def test_search_endpoints_no_results(self, service_model: ServiceModel):
        """æµ‹è¯•æœç´¢æ— ç»“æœçš„æƒ…å†µ"""
        search_params = {
            "keyword": "ä¸å­˜åœ¨çš„å…³é”®å­—xyz123", 
            "tag": "", 
            "method": "", 
            "path_pattern": ""
        }
        
        results = search_endpoints.search_endpoints(service_model, search_params)
        assert isinstance(results, list)
        assert len(results) == 0, "åº”è¯¥æ²¡æœ‰æœç´¢ç»“æœ"
        
        formatted = search_endpoints.format_search_results(results, search_params)
        assert "æœªæ‰¾åˆ°åŒ¹é…çš„æ¥å£" in formatted
        print("âœ… æ— ç»“æœæœç´¢å¤„ç†æ­£ç¡®")
    
    def test_get_endpoint_details_by_id(self, service_model: ServiceModel):
        """æµ‹è¯•é€šè¿‡IDè·å–ç«¯ç‚¹è¯¦æƒ…"""
        if not service_model.endpoints:
            pytest.skip("æ²¡æœ‰ç«¯ç‚¹æ•°æ®ï¼Œè·³è¿‡è¯¦æƒ…æŸ¥è¯¢æµ‹è¯•")
        
        # ä½¿ç”¨ç¬¬ä¸€ä¸ªç«¯ç‚¹è¿›è¡Œæµ‹è¯•
        endpoint_id = service_model.endpoints[0].id
        endpoint, found = get_endpoint_details.get_endpoint_details(service_model, endpoint_id)
        
        assert found, f"åº”è¯¥æ‰¾åˆ°ç«¯ç‚¹: {endpoint_id}"
        assert endpoint is not None, "ç«¯ç‚¹å¯¹è±¡ä¸åº”ä¸ºç©º"
        assert endpoint.id == endpoint_id, "è¿”å›çš„ç«¯ç‚¹IDåº”è¯¥åŒ¹é…"
        
        # æµ‹è¯•æ ¼å¼åŒ–è¯¦æƒ…
        formatted = get_endpoint_details.format_endpoint_details(endpoint, service_model)
        assert isinstance(formatted, str)
        assert len(formatted) > 0
        assert endpoint.method.upper() in formatted
        assert endpoint.path in formatted
        
        print(f"âœ… ç«¯ç‚¹è¯¦æƒ…æŸ¥è¯¢æµ‹è¯•é€šè¿‡ï¼ŒID: {endpoint_id}")
    
    def test_get_endpoint_details_by_method_path(self, service_model: ServiceModel):
        """æµ‹è¯•é€šè¿‡æ–¹æ³•å’Œè·¯å¾„è·å–ç«¯ç‚¹è¯¦æƒ…"""
        if not service_model.endpoints:
            pytest.skip("æ²¡æœ‰ç«¯ç‚¹æ•°æ®ï¼Œè·³è¿‡è¯¦æƒ…æŸ¥è¯¢æµ‹è¯•")
        
        # ä½¿ç”¨ç¬¬ä¸€ä¸ªç«¯ç‚¹è¿›è¡Œæµ‹è¯•
        first_endpoint = service_model.endpoints[0]
        method = first_endpoint.method
        path = first_endpoint.path
        
        endpoint, found = get_endpoint_details.get_endpoint_details(service_model, method, path)
        
        assert found, f"åº”è¯¥æ‰¾åˆ°ç«¯ç‚¹: {method} {path}"
        assert endpoint is not None, "ç«¯ç‚¹å¯¹è±¡ä¸åº”ä¸ºç©º"
        assert endpoint.method == method, "è¿”å›çš„ç«¯ç‚¹æ–¹æ³•åº”è¯¥åŒ¹é…"
        assert endpoint.path == path, "è¿”å›çš„ç«¯ç‚¹è·¯å¾„åº”è¯¥åŒ¹é…"
        
        print(f"âœ… æ–¹æ³•è·¯å¾„æŸ¥è¯¢æµ‹è¯•é€šè¿‡ï¼Œ{method} {path}")
    
    def test_get_endpoint_details_not_found(self, service_model: ServiceModel):
        """æµ‹è¯•æŸ¥è¯¢ä¸å­˜åœ¨çš„ç«¯ç‚¹"""
        # æµ‹è¯•ä¸å­˜åœ¨çš„ç«¯ç‚¹ID
        endpoint, found = get_endpoint_details.get_endpoint_details(service_model, "ä¸å­˜åœ¨çš„ID")
        assert not found, "åº”è¯¥æ‰¾ä¸åˆ°ä¸å­˜åœ¨çš„ç«¯ç‚¹"
        assert endpoint is None, "ä¸å­˜åœ¨çš„ç«¯ç‚¹åº”è¿”å›None"
        
        # æµ‹è¯•ä¸å­˜åœ¨çš„æ–¹æ³•å’Œè·¯å¾„
        endpoint, found = get_endpoint_details.get_endpoint_details(service_model, "INVALID", "/nonexistent")
        assert not found, "åº”è¯¥æ‰¾ä¸åˆ°ä¸å­˜åœ¨çš„ç«¯ç‚¹"
        assert endpoint is None, "ä¸å­˜åœ¨çš„ç«¯ç‚¹åº”è¿”å›None"
        
        print("âœ… ç«¯ç‚¹ä¸å­˜åœ¨æƒ…å†µå¤„ç†æ­£ç¡®")
    
    def test_list_schemas_overview(self, service_model: ServiceModel):
        """æµ‹è¯•Schemaåˆ—è¡¨åŠŸèƒ½"""
        schemas = list_schemas.list_schemas(service_model)
        assert isinstance(schemas, list), "Schemaåˆ—è¡¨åº”è¯¥æ˜¯list"
        
        # å¦‚æœæœ‰Schemaï¼ŒéªŒè¯æ•°æ®ç»“æ„
        if schemas:
            schema_info = schemas[0]
            required_keys = ["name", "type", "description", "has_properties", "property_count"]
            for key in required_keys:
                assert key in schema_info, f"Schemaä¿¡æ¯åº”åŒ…å«å­—æ®µ: {key}"
        
        # æµ‹è¯•æ ¼å¼åŒ–æ˜¾ç¤º
        formatted = list_schemas.format_schemas_list(schemas)
        assert isinstance(formatted, str)
        assert "æ•°æ®æ¨¡å‹" in formatted
        
        print(f"âœ… Schemaåˆ—è¡¨æµ‹è¯•é€šè¿‡ï¼Œå…± {len(schemas)} ä¸ªSchema")
    
    def test_list_schemas_empty_model(self, mock_empty_service_model: ServiceModel):
        """æµ‹è¯•ç©ºæ¨¡å‹çš„Schemaåˆ—è¡¨"""
        schemas = list_schemas.list_schemas(mock_empty_service_model)
        assert isinstance(schemas, list)
        assert len(schemas) == 0, "ç©ºæ¨¡å‹åº”è¯¥æ²¡æœ‰Schema"
        
        formatted = list_schemas.format_schemas_list(schemas)
        assert "æš‚æ— å¯ç”¨çš„æ•°æ®æ¨¡å‹å®šä¹‰" in formatted
        print("âœ… ç©ºSchemaåˆ—è¡¨å¤„ç†æ­£ç¡®")
    
    def test_get_schema_details_success(self, service_model: ServiceModel):
        """æµ‹è¯•Schemaè¯¦æƒ…æŸ¥è¯¢æˆåŠŸæƒ…å†µ"""
        if not service_model.schemas:
            pytest.skip("æ²¡æœ‰Schemaæ•°æ®ï¼Œè·³è¿‡è¯¦æƒ…æŸ¥è¯¢æµ‹è¯•")
        
        # ä½¿ç”¨ç¬¬ä¸€ä¸ªSchemaè¿›è¡Œæµ‹è¯•
        schema_name = list(service_model.schemas.keys())[0]
        schema, found = get_schema_details.get_schema_details(service_model, schema_name)
        
        assert found, f"åº”è¯¥æ‰¾åˆ°Schema: {schema_name}"
        assert schema is not None, "Schemaå¯¹è±¡ä¸åº”ä¸ºç©º"
        assert schema.name == schema_name, "è¿”å›çš„Schemaåç§°åº”è¯¥åŒ¹é…"
        
        # æµ‹è¯•æ ¼å¼åŒ–è¯¦æƒ…
        formatted = get_schema_details.format_schema_details(schema, service_model)
        assert isinstance(formatted, str)
        assert len(formatted) > 0
        assert schema_name in formatted
        
        print(f"âœ… Schemaè¯¦æƒ…æŸ¥è¯¢æµ‹è¯•é€šè¿‡ï¼Œåç§°: {schema_name}")
    
    def test_get_schema_details_not_found(self, service_model: ServiceModel):
        """æµ‹è¯•æŸ¥è¯¢ä¸å­˜åœ¨çš„Schema"""
        schema, found = get_schema_details.get_schema_details(service_model, "ä¸å­˜åœ¨çš„Schema")
        assert not found, "åº”è¯¥æ‰¾ä¸åˆ°ä¸å­˜åœ¨çš„Schema"
        assert schema is None, "ä¸å­˜åœ¨çš„Schemaåº”è¿”å›None"
        print("âœ… Schemaä¸å­˜åœ¨æƒ…å†µå¤„ç†æ­£ç¡®")
    
    def test_all_methods_with_empty_model(self, mock_empty_service_model: ServiceModel):
        """æµ‹è¯•æ‰€æœ‰æ–¹æ³•å¯¹ç©ºæ¨¡å‹çš„å¤„ç†"""
        # æµ‹è¯•æ‰€æœ‰ä¸»è¦æ–¹æ³•éƒ½èƒ½æ­£ç¡®å¤„ç†ç©ºæ¨¡å‹
        
        # list_endpoints
        overview = list_endpoints.format_endpoints_overview(mock_empty_service_model)
        assert "æš‚æ— å¯ç”¨çš„APIç«¯ç‚¹" in overview
        
        # search_endpoints
        results = search_endpoints.search_endpoints(mock_empty_service_model, {"keyword": "test"})
        assert len(results) == 0
        
        # get_endpoint_details
        endpoint, found = get_endpoint_details.get_endpoint_details(mock_empty_service_model, "test")
        assert not found
        
        # list_schemas
        schemas = list_schemas.list_schemas(mock_empty_service_model)
        assert len(schemas) == 0
        
        # get_schema_details
        schema, found = get_schema_details.get_schema_details(mock_empty_service_model, "test")
        assert not found
        
        print("âœ… æ‰€æœ‰æ–¹æ³•çš„ç©ºæ¨¡å‹å¤„ç†æµ‹è¯•é€šè¿‡")
    
    @pytest.mark.parametrize("method_name,args", [
        ("list_endpoints", []),
        ("search_endpoints", [{"keyword": "test"}]),
        ("get_endpoint_details", ["test_id"]),
        ("list_schemas", []),
        ("get_schema_details", ["test_schema"]),
    ])
    def test_method_error_handling(self, method_name: str, args: List[Any], service_model: ServiceModel):
        """æµ‹è¯•æ–¹æ³•çš„é”™è¯¯å¤„ç†"""
        # è¿™ä¸ªæµ‹è¯•ç¡®ä¿æ‰€æœ‰æ–¹æ³•éƒ½èƒ½å¤„ç†å„ç§è¾“å…¥è€Œä¸å´©æºƒ
        try:
            if method_name == "list_endpoints":
                list_endpoints.format_endpoints_overview(service_model)
            elif method_name == "search_endpoints":
                search_endpoints.search_endpoints(service_model, args[0])
            elif method_name == "get_endpoint_details":
                get_endpoint_details.get_endpoint_details(service_model, args[0])
            elif method_name == "list_schemas":
                list_schemas.list_schemas(service_model)
            elif method_name == "get_schema_details":
                get_schema_details.get_schema_details(service_model, args[0])
        except Exception as e:
            pytest.fail(f"æ–¹æ³• {method_name} åº”è¯¥èƒ½å¤„ç†è¾“å…¥è€Œä¸æŠ›å‡ºå¼‚å¸¸: {e}")
        
        print(f"âœ… æ–¹æ³• {method_name} é”™è¯¯å¤„ç†æµ‹è¯•é€šè¿‡")
    
    def test_search_performance(self, service_model: ServiceModel):
        """æµ‹è¯•æœç´¢æ€§èƒ½"""
        if not service_model.endpoints:
            pytest.skip("æ²¡æœ‰ç«¯ç‚¹æ•°æ®ï¼Œè·³è¿‡æ€§èƒ½æµ‹è¯•")
        
        import time
        
        # æµ‹è¯•æœç´¢æ€§èƒ½ - åº”è¯¥èƒ½åœ¨åˆç†æ—¶é—´å†…å®Œæˆ
        start_time = time.time()
        
        for _ in range(10):  # æ‰§è¡Œ10æ¬¡æœç´¢
            search_endpoints.search_endpoints(service_model, {"keyword": "api"})
        
        end_time = time.time()
        avg_time = (end_time - start_time) / 10
        
        # å¹³å‡æœç´¢æ—¶é—´åº”è¯¥å°äº100msï¼ˆç›¸å¯¹å®½æ¾çš„é™åˆ¶ï¼‰
        assert avg_time < 0.1, f"æœç´¢æ€§èƒ½è¿‡æ…¢: {avg_time:.4f}s per search"
        print(f"âœ… æœç´¢æ€§èƒ½æµ‹è¯•é€šè¿‡ï¼Œå¹³å‡è€—æ—¶: {avg_time:.4f}s")
    
    def test_output_format_consistency(self, service_model: ServiceModel):
        """æµ‹è¯•è¾“å‡ºæ ¼å¼çš„ä¸€è‡´æ€§"""
        # ç¡®ä¿æ‰€æœ‰æ–¹æ³•çš„è¾“å‡ºéƒ½æ˜¯å­—ç¬¦ä¸²ä¸”åŒ…å«é¢„æœŸçš„æ ¼å¼æ ‡è®°
        
        if service_model.endpoints:
            # ç«¯ç‚¹æ¦‚è§ˆæ ¼å¼
            overview = list_endpoints.format_endpoints_overview(service_model)
            assert "##" in overview, "åº”åŒ…å«Markdownæ ‡é¢˜æ ¼å¼"
            assert "**" in overview, "åº”åŒ…å«Markdownç²—ä½“æ ¼å¼"
            
            # æœç´¢ç»“æœæ ¼å¼
            results = search_endpoints.search_endpoints(service_model, {"keyword": ""})
            formatted = search_endpoints.format_search_results(results, {"keyword": ""})
            assert "##" in formatted, "æœç´¢ç»“æœåº”åŒ…å«æ ‡é¢˜"
            
            # ç«¯ç‚¹è¯¦æƒ…æ ¼å¼
            endpoint, found = get_endpoint_details.get_endpoint_details(service_model, service_model.endpoints[0].id)
            if found:
                formatted = get_endpoint_details.format_endpoint_details(endpoint, service_model)
                assert "##" in formatted, "ç«¯ç‚¹è¯¦æƒ…åº”åŒ…å«æ ‡é¢˜"
        
        if service_model.schemas:
            # Schemaåˆ—è¡¨æ ¼å¼
            schemas = list_schemas.list_schemas(service_model)
            formatted = list_schemas.format_schemas_list(schemas)
            assert "##" in formatted, "Schemaåˆ—è¡¨åº”åŒ…å«æ ‡é¢˜"
            
            # Schemaè¯¦æƒ…æ ¼å¼
            schema_name = list(service_model.schemas.keys())[0]
            schema, found = get_schema_details.get_schema_details(service_model, schema_name)
            if found:
                formatted = get_schema_details.format_schema_details(schema, service_model)
                assert "##" in formatted, "Schemaè¯¦æƒ…åº”åŒ…å«æ ‡é¢˜"
        
        print("âœ… è¾“å‡ºæ ¼å¼ä¸€è‡´æ€§æµ‹è¯•é€šè¿‡")


# æµ‹è¯•è¿è¡Œé…ç½®
if __name__ == "__main__":
    # å¯ä»¥ç›´æ¥è¿è¡Œæ­¤æ–‡ä»¶è¿›è¡Œæµ‹è¯•
    pytest.main([__file__, "-v", "--tb=short"])
`

// ReadmeMdTemplate README.mdé¡¹ç›®æ–‡æ¡£æ¨¡æ¿
const ReadmeMdTemplate = `# {{.ServiceTitle}} MCP å·¥å…·

{{.ServiceTitle}}çš„MCPï¼ˆModel Context Protocolï¼‰æœåŠ¡å™¨ï¼Œé€šè¿‡æ ‡å‡†è¾“å…¥è¾“å‡ºæä¾›APIæ–‡æ¡£æŸ¥è¯¢åŠŸèƒ½ã€‚

> ğŸ¤– æ­¤é¡¹ç›®ç”± swagger2mcp å·¥å…·è‡ªåŠ¨ç”Ÿæˆ

## åŠŸèƒ½ç‰¹æ€§

- **APIæ–‡æ¡£æŸ¥è¯¢**: æŸ¥çœ‹æ‰€æœ‰å¯ç”¨çš„APIç«¯ç‚¹
- **æ™ºèƒ½æœç´¢**: æ”¯æŒå…³é”®å­—ã€æ ‡ç­¾ã€HTTPæ–¹æ³•ã€è·¯å¾„æ¨¡å¼æœç´¢
- **è¯¦ç»†ä¿¡æ¯**: è·å–ç«¯ç‚¹å‚æ•°ã€è¯·æ±‚ä½“ã€å“åº”çš„è¯¦ç»†ä¿¡æ¯
- **æ•°æ®æ¨¡å‹**: æµè§ˆå’ŒæŸ¥çœ‹Schemaå®šä¹‰
- **MCPåè®®**: éµå¾ªMCPåè®®æ ‡å‡†ï¼Œä¸å„ç§AIå®¢æˆ·ç«¯å…¼å®¹

## å¿«é€Ÿå¼€å§‹

### ç³»ç»Ÿè¦æ±‚

- Python 3.8 æˆ–æ›´é«˜ç‰ˆæœ¬
- pip åŒ…ç®¡ç†å™¨

### å®‰è£…

1. å®‰è£…ä¾èµ–:
   pip install -r requirements.txt

2. å¼€å‘å®‰è£…ï¼ˆå¯é€‰ï¼‰:
   pip install -e .

### ä½¿ç”¨æ–¹æ³•

ä½œä¸ºMCPæœåŠ¡å™¨è¿è¡Œ:
python -m {{.PackageName}}.main

## å¯ç”¨å·¥å…·

- **listEndpoints**: åˆ—å‡ºæ‰€æœ‰å¯ç”¨çš„APIç«¯ç‚¹
- **searchEndpoints**: æ ¹æ®æ¡ä»¶æœç´¢APIç«¯ç‚¹
- **getEndpointDetails**: è·å–æŒ‡å®šAPIç«¯ç‚¹çš„è¯¦ç»†ä¿¡æ¯
- **listSchemas**: åˆ—å‡ºæ‰€æœ‰å¯ç”¨çš„æ•°æ®æ¨¡å‹å®šä¹‰
- **getSchemaDetails**: è·å–æŒ‡å®šæ•°æ®æ¨¡å‹çš„è¯¦ç»†ä¿¡æ¯

## APIä¿¡æ¯

- **æœåŠ¡åç§°**: {{.ServiceTitle}}
- **ç‰ˆæœ¬**: {{.Version}}

---

> æ³¨æ„: è¿™æ˜¯ä¸€ä¸ªè‡ªåŠ¨ç”Ÿæˆçš„é¡¹ç›®ã€‚å¦‚éœ€æ›´æ–°ï¼Œè¯·ä¿®æ”¹åŸå§‹APIè§„èŒƒå¹¶é‡æ–°ç”Ÿæˆã€‚
`

// SetupPyTemplate setup.pyé¡¹ç›®å®‰è£…é…ç½®æ¨¡æ¿
const SetupPyTemplate = `"""
{{.ServiceTitle}} MCP å·¥å…·å®‰è£…é…ç½®
é€šè¿‡æ ‡å‡†è¾“å…¥è¾“å‡ºæä¾› MCP (Model Context Protocol) æœåŠ¡

Generated by swagger2mcp
"""

from setuptools import setup, find_packages
from pathlib import Path

# è¯»å–READMEæ–‡ä»¶ä½œä¸ºé•¿æè¿°
this_directory = Path(__file__).parent
long_description = (this_directory / "README.md").read_text(encoding='utf-8')

setup(
    name="{{.PackageName}}",
    version="{{.Version}}",
    author="{{.Author}}",
    author_email="noreply@example.com",
    description="{{.ServiceTitle}}çš„MCPæœåŠ¡å™¨ - æä¾›APIæ–‡æ¡£æŸ¥è¯¢åŠŸèƒ½",
    long_description=long_description,
    long_description_content_type="text/markdown",
    url="https://github.com/mark3labs/swagger2mcp",
    packages=find_packages(where="src"),
    package_dir={"": "src"},
    package_data={
        "{{.PackageName}}.spec": ["model.json"],
    },
    include_package_data=True,
    classifiers=[
        "Development Status :: 4 - Beta",
        "Intended Audience :: Developers",
        "Topic :: Software Development :: Documentation",
        "Topic :: Internet :: WWW/HTTP :: Dynamic Content",
        "License :: OSI Approved :: MIT License",
        "Programming Language :: Python :: 3",
        "Programming Language :: Python :: 3.8",
        "Programming Language :: Python :: 3.9",
        "Programming Language :: Python :: 3.10",
        "Programming Language :: Python :: 3.11",
        "Programming Language :: Python :: 3.12",
        "Operating System :: OS Independent",
    ],
    python_requires=">=3.8",
    install_requires=[
        "dataclasses-json>=0.6.0",
        "typing-extensions>=4.5.0",
    ],
    extras_require={
        "dev": [
            "black>=23.0.0",
            "mypy>=1.5.0", 
            "pytest>=7.4.0",
            "pytest-cov>=4.1.0",
            "flake8>=6.0.0",
            "isort>=5.12.0",
        ]
    },
    entry_points={
        "console_scripts": [
            "{{.ToolName}}={{.PackageName}}.main:main",
        ],
    },
    keywords="mcp api documentation openapi swagger",
    project_urls={
        "Documentation": "https://github.com/mark3labs/swagger2mcp",
        "Source": "https://github.com/mark3labs/swagger2mcp",
        "Tracker": "https://github.com/mark3labs/swagger2mcp/issues",
    },
)`

// RequirementsTxtTemplate requirements.txtè¿è¡Œæ—¶ä¾èµ–æ¨¡æ¿
const RequirementsTxtTemplate = `# {{.ServiceTitle}} MCP å·¥å…·è¿è¡Œæ—¶ä¾èµ–
# Generated by swagger2mcp

# MCPåè®®ç›¸å…³ä¾èµ–
dataclasses-json>=0.6.0
typing-extensions>=4.5.0

# JSONå¤„ç†å’Œæ•°æ®éªŒè¯
# æ³¨æ„ï¼šPython 3.8+ å†…ç½®äº†jsonæ¨¡å—ï¼Œæ— éœ€é¢å¤–ä¾èµ–
`

// RequirementsDevTxtTemplate requirements-dev.txtå¼€å‘ä¾èµ–æ¨¡æ¿
const RequirementsDevTxtTemplate = `# {{.ServiceTitle}} MCP å·¥å…·å¼€å‘ä¾èµ–
# Generated by swagger2mcp

# åŒ…å«è¿è¡Œæ—¶ä¾èµ–
-r requirements.txt

# ä»£ç æ ¼å¼åŒ–
black>=23.0.0
isort>=5.12.0

# ç±»å‹æ£€æŸ¥
mypy>=1.5.0
types-setuptools>=68.0.0

# æµ‹è¯•æ¡†æ¶
pytest>=7.4.0
pytest-cov>=4.1.0
pytest-asyncio>=0.21.0

# ä»£ç è´¨é‡æ£€æŸ¥
flake8>=6.0.0
pylint>=2.17.0
bandit>=1.7.5  # å®‰å…¨æ¼æ´æ£€æŸ¥
safety>=2.3.0  # ä¾èµ–å®‰å…¨æ£€æŸ¥

# ä»£ç å¤æ‚åº¦æ£€æŸ¥
radon>=6.0.1
xenon>=0.9.0

# æ–‡æ¡£å­—ç¬¦ä¸²æ£€æŸ¥
pydocstyle>=6.3.0

# å¯¼å…¥æ’åºæ£€æŸ¥
isort[colors]>=5.12.0

# é¢„æäº¤é’©å­
pre-commit>=3.3.0

# Python 3.8+ å…¼å®¹æ€§æ£€æŸ¥
pyupgrade>=3.10.0
vermin>=1.5.2

# æ„å»ºå·¥å…·
build>=0.10.0
twine>=4.0.0
`

// PyprojectTomlTemplate pyproject.tomlç°ä»£Pythoné¡¹ç›®é…ç½®æ¨¡æ¿
const PyprojectTomlTemplate = `# {{.ServiceTitle}} MCP å·¥å…·é¡¹ç›®é…ç½®
# Generated by swagger2mcp

[build-system]
requires = ["setuptools>=61.0", "wheel"]
build-backend = "setuptools.build_meta"

[project]
name = "{{.PackageName}}"
version = "{{.Version}}"
description = "{{.ServiceTitle}}çš„MCPæœåŠ¡å™¨ - æä¾›APIæ–‡æ¡£æŸ¥è¯¢åŠŸèƒ½"
authors = [
    {name = "{{.Author}}"},
]
readme = "README.md"
requires-python = ">=3.8"
classifiers = [
    "Development Status :: 4 - Beta",
    "Intended Audience :: Developers",
    "Topic :: Software Development :: Documentation",
    "Topic :: Internet :: WWW/HTTP :: Dynamic Content",
    "License :: OSI Approved :: MIT License",
    "Programming Language :: Python :: 3",
    "Programming Language :: Python :: 3.8",
    "Programming Language :: Python :: 3.9",
    "Programming Language :: Python :: 3.10",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: Python :: 3.12",
    "Operating System :: OS Independent",
]
dependencies = [
    "dataclasses-json>=0.6.0",
    "typing-extensions>=4.5.0",
]
keywords = ["mcp", "api", "documentation", "openapi", "swagger"]

[project.urls]
Documentation = "https://github.com/mark3labs/swagger2mcp"
Source = "https://github.com/mark3labs/swagger2mcp"
Tracker = "https://github.com/mark3labs/swagger2mcp/issues"

[project.scripts]
"{{.ToolName}}" = "{{.PackageName}}.main:main"

[project.optional-dependencies]
dev = [
    "black>=23.0.0",
    "isort>=5.12.0", 
    "mypy>=1.5.0",
    "pytest>=7.4.0",
    "pytest-cov>=4.1.0",
    "flake8>=6.0.0",
    "pylint>=2.17.0",
]

# å·¥å…·é…ç½®
[tool.black]
line-length = 88
target-version = ['py38']
include = '\.pyi?$'
extend-exclude = '''
# A regex preceded by ^/ will apply only to files and directories
# in the root of the project.
^/docs/  # exclude docs directory
'''

[tool.isort]
profile = "black"
line_length = 88
multi_line_output = 3
include_trailing_comma = true
force_grid_wrap = 0
use_parentheses = true
ensure_newline_before_comments = true

[tool.mypy]
python_version = "3.8"
strict = true
warn_return_any = true
warn_unused_configs = true
disallow_untyped_defs = true
disallow_incomplete_defs = true
check_untyped_defs = true
disallow_untyped_decorators = true
no_implicit_optional = true
warn_redundant_casts = true
warn_unused_ignores = true
warn_no_return = true
warn_unreachable = true
strict_equality = true

[[tool.mypy.overrides]]
module = ["tests.*"]
disallow_untyped_defs = false

[tool.pytest.ini_options]
testpaths = ["tests"]
python_files = ["test_*.py", "*_test.py"]
python_classes = ["Test*"]
python_functions = ["test_*"]
addopts = [
    "--strict-markers",
    "--strict-config",
    "--cov={{.PackageName}}",
    "--cov-report=term-missing",
    "--cov-report=html",
    "--cov-report=xml",
]
markers = [
    "slow: marks tests as slow (deselect with '-m \"not slow\"')",
    "integration: marks tests as integration tests",
]

[tool.coverage.run]
source = ["src"]
branch = true

[tool.coverage.report]
exclude_lines = [
    "pragma: no cover",
    "def __repr__",
    "if self.debug:",
    "if settings.DEBUG",
    "raise AssertionError",
    "raise NotImplementedError",
    "if 0:",
    "if __name__ == .__main__.:",
    "class .*\\bProtocol\\):",
    "@(abc\\.)?abstractmethod",
]

[tool.flake8]
max-line-length = 88
select = ["E", "F", "W", "C90"]
ignore = [
    "E203",  # whitespace before ':'
    "E501",  # line too long (handled by black)
    "W503",  # line break before binary operator
]
exclude = [
    ".git",
    "__pycache__",
    "build",
    "dist",
    ".eggs",
    "*.egg-info",
    ".venv",
    "venv",
]

[tool.bandit]
targets = ["src/{{.PackageName}}"]
exclude_dirs = ["tests"]
skips = ["B101", "B601"]

[tool.pydocstyle]
convention = "google"
add_ignore = "D100,D104"

[tool.pyupgrade]
py38-plus = true

[tool.vermin]
targets = ["3.8-"]
backport = ["typing"]
no-tips = true
`

// MakefileTemplate Makefileå¼€å‘ä»»åŠ¡ç®¡ç†æ¨¡æ¿
const MakefileTemplate = `# {{.ServiceTitle}} MCP å·¥å…·å¼€å‘ä»»åŠ¡
# Generated by swagger2mcp

.PHONY: help install install-dev test format lint clean build upload check security quality compat upgrade

# é»˜è®¤ç›®æ ‡ï¼šæ˜¾ç¤ºå¸®åŠ©ä¿¡æ¯
help:
	@echo "{{.ServiceTitle}} MCP å·¥å…·å¼€å‘å‘½ä»¤:"
	@echo ""
	@echo "  install     å®‰è£…é¡¹ç›®ä¾èµ–"
	@echo "  install-dev å®‰è£…å¼€å‘ä¾èµ–" 
	@echo "  test        è¿è¡Œæµ‹è¯•"
	@echo "  format      æ ¼å¼åŒ–ä»£ç "
	@echo "  lint        æ£€æŸ¥ä»£ç è´¨é‡"
	@echo "  security    å®‰å…¨æ¼æ´æ£€æŸ¥"
	@echo "  quality     å…¨é¢ä»£ç è´¨é‡æ£€æŸ¥"
	@echo "  compat      Python 3.8+ å…¼å®¹æ€§æ£€æŸ¥"
	@echo "  upgrade     å‡çº§ä»£ç åˆ°ç°ä»£Pythonè¯­æ³•"
	@echo "  clean       æ¸…ç†æ„å»ºæ–‡ä»¶"
	@echo "  build       æ„å»ºé¡¹ç›®"
	@echo "  upload      ä¸Šä¼ åˆ°PyPI"
	@echo "  check       è¿è¡Œæ‰€æœ‰æ£€æŸ¥"
	@echo ""

# å®‰è£…é¡¹ç›®ä¾èµ–
install:
	pip install -e .

# å®‰è£…å¼€å‘ä¾èµ–
install-dev:
	pip install -e ".[dev]"
	pip install -r requirements-dev.txt

# è¿è¡Œæµ‹è¯•
test:
	pytest tests/ -v --cov={{.PackageName}} --cov-report=term-missing --cov-report=html

# æ ¼å¼åŒ–ä»£ç 
format:
	pyupgrade --py38-plus src/**/*.py tests/**/*.py
	black src/ tests/
	isort src/ tests/

# æ£€æŸ¥ä»£ç è´¨é‡ (åŸºç¡€æ£€æŸ¥)
lint:
	flake8 src/ tests/
	mypy src/
	black --check src/ tests/
	isort --check-only src/ tests/

# å®‰å…¨æ¼æ´æ£€æŸ¥
security:
	bandit -r src/ -f json -o bandit-report.json || bandit -r src/
	safety check --json --output safety-report.json || safety check

# å…¨é¢ä»£ç è´¨é‡æ£€æŸ¥
quality: lint security
	pylint src/{{.PackageName}}/ --output-format=json --output=pylint-report.json || pylint src/{{.PackageName}}/
	pydocstyle src/{{.PackageName}}/ || echo "æ–‡æ¡£å­—ç¬¦ä¸²æ£€æŸ¥å®Œæˆ"
	radon cc src/{{.PackageName}}/ -a -nb
	radon mi src/{{.PackageName}}/ -nb
	xenon --max-absolute A --max-modules A --max-average A src/{{.PackageName}}/

# Python 3.8+ å…¼å®¹æ€§æ£€æŸ¥
compat:
	vermin -t=3.8- src/{{.PackageName}}/
	vermin -t=3.8- tests/

# å‡çº§ä»£ç åˆ°ç°ä»£Pythonè¯­æ³•
upgrade:
	pyupgrade --py38-plus src/**/*.py tests/**/*.py

# æ¸…ç†æ„å»ºæ–‡ä»¶å’ŒæŠ¥å‘Š
clean:
	rm -rf build/
	rm -rf dist/
	rm -rf *.egg-info/
	find . -type d -name __pycache__ -delete
	find . -type f -name "*.pyc" -delete
	find . -type f -name "*.pyo" -delete
	find . -type f -name "*~" -delete
	find . -type f -name ".*~" -delete
	rm -rf .coverage
	rm -rf htmlcov/
	rm -rf .pytest_cache/
	rm -rf .mypy_cache/
	rm -f bandit-report.json safety-report.json pylint-report.json

# æ„å»ºé¡¹ç›®
build: clean
	python -m build

# ä¸Šä¼ åˆ°PyPI (éœ€è¦å…ˆé…ç½®API token)
upload: build
	python -m twine upload dist/*

# è¿è¡Œæ‰€æœ‰æ£€æŸ¥
check: quality compat test
	@echo "æ‰€æœ‰æ£€æŸ¥å®Œæˆ!"

# å¿«é€Ÿæ£€æŸ¥ï¼ˆç”¨äºCI/CDï¼‰
ci-check:
	pytest tests/ --tb=short -q
	flake8 src/
	mypy src/
	black --check src/ tests/
	bandit -r src/ -q
	vermin -t=3.8- src/{{.PackageName}}/ -q

# é¢„æäº¤æ£€æŸ¥
pre-commit: format quality
	@echo "é¢„æäº¤æ£€æŸ¥é€šè¿‡!"
`

// GitignoreTemplate .gitignoreæ–‡ä»¶æ¨¡æ¿
const GitignoreTemplate = `# {{.ServiceTitle}} MCP å·¥å…· .gitignore
# Generated by swagger2mcp

# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/

# Translations
*.mo
*.pot

# Django stuff:
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
.pybuilder/
target/

# Jupyter Notebook
.ipynb_checkpoints

# IPython
profile_default/
ipython_config.py

# pyenv
.python-version

# pipenv
Pipfile.lock

# poetry
poetry.lock

# pdm
.pdm.toml

# PEP 582
__pypackages__/

# Celery stuff
celerybeat-schedule
celerybeat.pid

# SageMath parsed files
*.sage.py

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Pyre type checker
.pyre/

# pytype static type analyzer
.pytype/

# Cython debug symbols
cython_debug/

# PyCharm
.idea/

# VSCode
.vscode/

# macOS
.DS_Store

# Windows
Thumbs.db
ehthumbs.db
Desktop.ini
`

// EditorconfigTemplate .editorconfigç¼–è¾‘å™¨é…ç½®æ¨¡æ¿
const EditorconfigTemplate = `# {{.ServiceTitle}} MCP å·¥å…·ç¼–è¾‘å™¨é…ç½®
# Generated by swagger2mcp

root = true

[*]
charset = utf-8
end_of_line = lf
insert_final_newline = true
trim_trailing_whitespace = true
indent_style = space
indent_size = 4

[*.{py,pyi}]
indent_size = 4
max_line_length = 88

[*.{json,yaml,yml}]
indent_size = 2

[*.md]
trim_trailing_whitespace = false

[Makefile]
indent_style = tab
`

// PreCommitConfigTemplate pre-commité…ç½®æ¨¡æ¿
const PreCommitConfigTemplate = `# {{.ServiceTitle}} MCP å·¥å…·é¢„æäº¤é’©å­é…ç½®
# Generated by swagger2mcp

repos:
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.4.0
    hooks:
      - id: trailing-whitespace
      - id: end-of-file-fixer
      - id: check-yaml
      - id: check-json
      - id: check-merge-conflict
      - id: debug-statements
      - id: check-docstring-first

  - repo: https://github.com/asottile/pyupgrade
    rev: v3.10.1
    hooks:
      - id: pyupgrade
        args: [--py38-plus]

  - repo: https://github.com/psf/black
    rev: 23.9.1
    hooks:
      - id: black
        language_version: python3

  - repo: https://github.com/pycqa/isort
    rev: 5.12.0
    hooks:
      - id: isort
        args: ["--profile", "black"]

  - repo: https://github.com/pycqa/flake8
    rev: 6.1.0
    hooks:
      - id: flake8
        additional_dependencies: [flake8-docstrings]

  - repo: https://github.com/pre-commit/mirrors-mypy
    rev: v1.5.1
    hooks:
      - id: mypy
        additional_dependencies: [types-setuptools]

  - repo: https://github.com/PyCQA/bandit
    rev: 1.7.5
    hooks:
      - id: bandit
        args: ["-c", "pyproject.toml"]

  - repo: https://github.com/pycqa/pydocstyle
    rev: 6.3.0
    hooks:
      - id: pydocstyle
        args: [--convention=google]

  - repo: https://github.com/netromdk/vermin
    rev: v1.5.2
    hooks:
      - id: vermin
        args: ["-t=3.8-", "--no-tips"]
`

// MyPyConfigTemplate mypy.inié…ç½®æ¨¡æ¿
const MyPyConfigTemplate = `# {{.ServiceTitle}} MCP å·¥å…· MyPy é…ç½®
# Generated by swagger2mcp

[mypy]
python_version = 3.8
warn_return_any = True
warn_unused_configs = True
disallow_untyped_defs = True
disallow_incomplete_defs = True
check_untyped_defs = True
disallow_untyped_decorators = True
no_implicit_optional = True
warn_redundant_casts = True
warn_unused_ignores = True
warn_no_return = True
warn_unreachable = True
strict_equality = True
show_error_codes = True

# ç¬¬ä¸‰æ–¹åº“é…ç½®
[mypy-pytest.*]
ignore_missing_imports = True

[mypy-setuptools.*]
ignore_missing_imports = True
`

// PylintRcTemplate .pylintrcé…ç½®æ¨¡æ¿
const PylintRcTemplate = `# {{.ServiceTitle}} MCP å·¥å…· Pylint é…ç½®  
# Generated by swagger2mcp

[MASTER]
extension-pkg-whitelist=
jobs=1
limit-inference-results=100
persistent=yes
suggestion-mode=yes
unsafe-load-any-extension=no

[MESSAGES CONTROL]
confidence=
disable=raw-checker-failed,
        bad-inline-option,
        locally-disabled,
        file-ignored,
        suppressed-message,
        useless-suppression,
        deprecated-pragma,
        use-symbolic-message-instead,
        missing-module-docstring,
        too-few-public-methods

[REPORTS]
evaluation=10.0 - ((float(5 * error + warning + refactor + convention) / statement) * 10)
output-format=text
reports=no
score=yes

[REFACTORING]
max-nested-blocks=5
never-returning-functions=sys.exit

[SIMILARITIES]
ignore-comments=yes
ignore-docstrings=yes
ignore-imports=no
min-similarity-lines=4

[SPELLING]
spelling-dict=
spelling-ignore-words=
spelling-private-dict-file=

[TYPECHECK]
contextmanager-decorators=contextlib.contextmanager
generated-members=
ignore-mixin-members=yes
ignore-none=yes
ignore-on-opaque-inference=yes
ignored-classes=optparse.Values,thread._local,_thread._local
ignored-modules=
missing-member-hint=yes
missing-member-hint-distance=1
missing-member-max-choices=1

[VARIABLES]
additional-builtins=
allow-global-unused-variables=yes
callbacks=cb_,_cb
dummy-variables-rgx=_+$|(_[a-zA-Z0-9_]*[a-zA-Z0-9]+?$)|dummy|^ignored_|^unused_
ignored-argument-names=_.*|^ignored_|^unused_
init-import=no
redefining-builtins-modules=six.moves,past.builtins,future.builtins,builtins,io

[FORMAT]
expected-line-ending-format=
ignore-long-lines=^\s*(# )?<?https?://\S+>?$
indent-after-paren=4
indent-string='    '
max-line-length=88
max-module-lines=1000
no-space-check=trailing-comma,dict-separator
single-line-class-stmt=no
single-line-if-stmt=no

[LOGGING]
logging-format-style=old
logging-modules=logging

[MISCELLANEOUS]
notes=FIXME,XXX,TODO

[BASIC]
argument-naming-style=snake_case
attr-naming-style=snake_case
bad-names=foo,bar,baz,toto,tutu,tata
class-attribute-naming-style=any
class-naming-style=PascalCase
const-naming-style=UPPER_CASE
docstring-min-length=-1
function-naming-style=snake_case
good-names=i,j,k,ex,Run,_
include-naming-hint=no
inlinevar-naming-style=any
method-naming-style=snake_case
module-naming-style=snake_case
name-group=
no-docstring-rgx=^_
property-classes=abc.abstractproperty
variable-naming-style=snake_case

[STRING]
check-str-concat-over-line-jumps=no

[IMPORTS]
allow-wildcard-with-all=no
analyse-fallback-blocks=no
deprecated-modules=optparse,tkinter.tix

[CLASSES]
defining-attr-methods=__init__,__new__,setUp,__post_init__
exclude-protected=_asdict,_fields,_replace,_source,_make
valid-classmethod-first-arg=cls
valid-metaclass-classmethod-first-arg=cls

[DESIGN]
max-args=5
max-attributes=7
max-bool-expr=5
max-branches=12
max-locals=15
max-parents=7
max-public-methods=20
max-returns=6
max-statements=50
min-public-methods=2

[EXCEPTIONS]
overgeneral-exceptions=BaseException,Exception
`
