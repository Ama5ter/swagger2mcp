package pyemitter

import (
	"bytes"
	"fmt"
	"strings"
	"text/template"

	genspec "github.com/mark3labs/swagger2mcp/internal/spec"
)

// TemplateData 包含所有模板需要的变量
type TemplateData struct {
	ToolName     string                `json:"tool_name"`     // 工具名称
	PackageName  string                `json:"package_name"`  // Python包名
	ServiceTitle string                `json:"service_title"` // 服务标题
	ServiceModel *genspec.ServiceModel `json:"service_model"` // 服务模型
	Version      string                `json:"version"`       // 版本号
	Author       string                `json:"author"`        // 作者信息
}

// RenderTemplate 渲染模板内容，支持动态内容替换
func RenderTemplate(templateContent string, data TemplateData) (string, error) {
	// 创建模板函数映射
	funcMap := template.FuncMap{
		"ToLower":    strings.ToLower,
		"ToUpper":    strings.ToUpper,
		"Title":      strings.Title,
		"Replace":    strings.ReplaceAll,
		"TrimSpace":  strings.TrimSpace,
		"Join":       strings.Join,
		"Split":      strings.Split,
		"Contains":   strings.Contains,
		"HasPrefix":  strings.HasPrefix,
		"HasSuffix":  strings.HasSuffix,
		"Indent":     indentLines,
		"Quote":      quoteString,
		"DocString":  formatDocString,
		"PythonName": toPythonName,
		"SafeString": toSafeString,
	}

	// 解析模板
	tmpl, err := template.New("template").Funcs(funcMap).Parse(templateContent)
	if err != nil {
		return "", fmt.Errorf("解析模板失败: %w", err)
	}

	// 执行模板渲染
	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return "", fmt.Errorf("渲染模板失败: %w", err)
	}

	return buf.String(), nil
}

// indentLines 为每行添加指定的缩进
func indentLines(indent string, text string) string {
	lines := strings.Split(text, "\n")
	result := make([]string, len(lines))
	for i, line := range lines {
		if strings.TrimSpace(line) != "" {
			result[i] = indent + line
		} else {
			result[i] = line
		}
	}
	return strings.Join(result, "\n")
}

// quoteString 为字符串添加引号并转义特殊字符
func quoteString(s string) string {
	return fmt.Sprintf("%q", s)
}

// formatDocString 格式化Python文档字符串
func formatDocString(text string) string {
	if strings.TrimSpace(text) == "" {
		return ""
	}

	lines := strings.Split(strings.TrimSpace(text), "\n")
	if len(lines) == 1 {
		return fmt.Sprintf(`"""%s"""`, lines[0])
	}

	var result []string
	result = append(result, `"""`)
	for _, line := range lines {
		result = append(result, line)
	}
	result = append(result, `"""`)

	return strings.Join(result, "\n")
}

// toPythonName 将字符串转换为有效的Python标识符
func toPythonName(s string) string {
	// 替换特殊字符为下划线
	s = strings.ReplaceAll(s, "-", "_")
	s = strings.ReplaceAll(s, " ", "_")
	s = strings.ReplaceAll(s, ".", "_")
	s = strings.ReplaceAll(s, "/", "_")

	// 转换为小写
	s = strings.ToLower(s)

	// 移除不允许的字符，只保留字母数字和下划线
	var result strings.Builder
	for i, r := range s {
		if (r >= 'a' && r <= 'z') || (r >= '0' && r <= '9') || r == '_' {
			// 第一个字符不能是数字
			if i == 0 && r >= '0' && r <= '9' {
				result.WriteString("_")
			}
			result.WriteRune(r)
		}
	}

	name := result.String()
	if name == "" {
		return "unknown"
	}

	// 去除开头和结尾的下划线
	name = strings.Trim(name, "_")
	if name == "" {
		return "unknown"
	}

	return name
}

// toSafeString 转换为安全的字符串（用于文件名等）
func toSafeString(s string) string {
	// 替换特殊字符
	replacements := map[string]string{
		"<":  "lt",
		">":  "gt",
		"\"": "quote",
		"'":  "apos",
		"&":  "amp",
		"/":  "_",
		"\\": "_",
		":":  "_",
		"*":  "_",
		"?":  "_",
		"|":  "_",
	}

	result := s
	for old, new := range replacements {
		result = strings.ReplaceAll(result, old, new)
	}

	return result
}

// NewTemplateData 创建新的模板数据实例
func NewTemplateData(toolName, packageName string, sm *genspec.ServiceModel) TemplateData {
	return TemplateData{
		ToolName:     toolName,
		PackageName:  packageName,
		ServiceTitle: sm.Title,
		ServiceModel: sm,
		Version:      "0.1.0",
		Author:       "Generated by swagger2mcp",
	}
}

// 模板渲染错误类型
type TemplateError struct {
	Template string
	Err      error
}

func (e *TemplateError) Error() string {
	return fmt.Sprintf("模板 %s 渲染失败: %v", e.Template, e.Err)
}

func (e *TemplateError) Unwrap() error {
	return e.Err
}

// RenderTemplateWithErrorHandling 渲染模板并提供详细错误处理
func RenderTemplateWithErrorHandling(templateName, templateContent string, data TemplateData) (string, error) {
	result, err := RenderTemplate(templateContent, data)
	if err != nil {
		return "", &TemplateError{
			Template: templateName,
			Err:      err,
		}
	}
	return result, nil
}

// ValidateTemplateData 验证模板数据的完整性
func ValidateTemplateData(data TemplateData) error {
	if data.ToolName == "" {
		return fmt.Errorf("工具名称不能为空")
	}
	if data.PackageName == "" {
		return fmt.Errorf("包名不能为空")
	}
	if data.ServiceModel == nil {
		return fmt.Errorf("服务模型不能为空")
	}
	if data.ServiceModel.Title == "" {
		return fmt.Errorf("服务标题不能为空")
	}
	return nil
}

// GetTemplateVariableNames 获取模板中使用的变量名列表（用于调试）
func GetTemplateVariableNames() []string {
	return []string{
		"ToolName",
		"PackageName",
		"ServiceTitle",
		"ServiceModel",
		"Version",
		"Author",
	}
}

// GetTemplateFunctionNames 获取可用的模板函数名列表（用于调试）
func GetTemplateFunctionNames() []string {
	return []string{
		"ToLower",
		"ToUpper",
		"Title",
		"Replace",
		"TrimSpace",
		"Join",
		"Split",
		"Contains",
		"HasPrefix",
		"HasSuffix",
		"Indent",
		"Quote",
		"DocString",
		"PythonName",
		"SafeString",
	}
}

// MainPyTemplate main.py程序入口点模板
const MainPyTemplate = `#!/usr/bin/env python3
"""
{{.ServiceTitle}} MCP 服务器
通过标准输入输出提供 MCP (Model Context Protocol) 服务

Generated by swagger2mcp
"""

import sys
import json
import logging
from typing import Dict, Any, Optional

from {{.PackageName}}.server import MCPServer


def setup_logging() -> None:
    """配置日志系统"""
    logging.basicConfig(
        level=logging.WARNING,  # 只显示警告和错误，避免干扰MCP通信
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        handlers=[logging.StreamHandler(sys.stderr)]  # 使用stderr，不干扰stdin/stdout
    )


def main() -> None:
    """MCP服务器主入口点"""
    try:
        # 配置日志
        setup_logging()
        logger = logging.getLogger(__name__)
        
        # 创建MCP服务器实例
        server = MCPServer(tool_name="{{.ToolName}}")
        
        # 启动标准输入输出通信
        logger.info("启动 {{.ServiceTitle}} MCP 服务器")
        server.run_stdio()
        
    except KeyboardInterrupt:
        # 处理Ctrl+C优雅退出
        sys.exit(0)
    except Exception as e:
        logger = logging.getLogger(__name__)
        logger.error(f"MCP服务器启动失败: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()
`

// ServerPyTemplate server.py MCP服务器核心实现模板
const ServerPyTemplate = `"""
MCP 服务器核心实现
处理 JSON-RPC 2.0 协议消息，支持标准 MCP 方法

Generated by swagger2mcp
"""

import sys
import json
import logging
from typing import Dict, Any, Optional, List, Union, Callable
from dataclasses import dataclass, asdict

from {{.PackageName}}.spec.loader import load_service_model
from {{.PackageName}}.mcp.methods import (
    list_endpoints,
    search_endpoints, 
    get_endpoint_details,
    list_schemas,
    get_schema_details
)


@dataclass
class JsonRpcError:
    """JSON-RPC 2.0 错误对象"""
    code: int
    message: str
    data: Optional[Any] = None


@dataclass
class JsonRpcResponse:
    """JSON-RPC 2.0 响应对象"""
    jsonrpc: str = "2.0"
    id: Optional[Union[str, int]] = None
    result: Optional[Any] = None
    error: Optional[JsonRpcError] = None


class MCPServer:
    """MCP 服务器主类，实现 JSON-RPC 2.0 协议处理"""
    
    # JSON-RPC 2.0 错误代码
    PARSE_ERROR = -32700
    INVALID_REQUEST = -32600
    METHOD_NOT_FOUND = -32601
    INVALID_PARAMS = -32602
    INTERNAL_ERROR = -32603
    
    def __init__(self, tool_name: str):
        """
        初始化 MCP 服务器
        
        Args:
            tool_name: 工具名称
        """
        self.tool_name = tool_name
        self.logger = logging.getLogger(f"{__name__}.MCPServer")
        
        # 初始化状态
        self.initialized = False
        
        try:
            # 加载服务模型
            self.service_model = load_service_model()
            self.logger.info(f"成功加载服务模型: {self.service_model.title}")
            
            # 注册工具方法
            self.tools = self._register_tools()
            self.logger.info(f"注册了 {len(self.tools)} 个工具方法")
            
        except Exception as e:
            self.logger.error(f"初始化失败: {e}")
            raise
    
    def _register_tools(self) -> Dict[str, Callable[..., Any]]:
        """注册所有可用的工具方法"""
        return {
            "listEndpoints": self._handle_list_endpoints,
            "searchEndpoints": self._handle_search_endpoints,
            "getEndpointDetails": self._handle_get_endpoint_details,
            "listSchemas": self._handle_list_schemas,
            "getSchemaDetails": self._handle_get_schema_details,
        }
    
    def run_stdio(self) -> None:
        """启动标准输入输出协议监听"""
        self.logger.info("开始监听标准输入")
        
        try:
            for line in sys.stdin:
                line = line.strip()
                if not line:
                    continue
                
                response = self._process_message(line)
                if response:
                    # 只有请求才需要响应，通知消息不需要响应
                    self._send_response(response)
                    
        except EOFError:
            # 标准输入关闭，正常退出
            self.logger.info("标准输入已关闭，服务器退出")
        except Exception as e:
            self.logger.error(f"处理标准输入时发生错误: {e}")
            raise
    
    def _process_message(self, message: str) -> Optional[JsonRpcResponse]:
        """
        处理接收到的 JSON-RPC 消息
        
        Args:
            message: JSON-RPC 消息字符串
            
        Returns:
            响应对象，如果是通知消息则返回None
        """
        try:
            # 解析JSON消息
            try:
                data = json.loads(message)
            except json.JSONDecodeError as e:
                self.logger.warning(f"JSON解析失败: {e}")
                return JsonRpcResponse(
                    error=JsonRpcError(
                        code=self.PARSE_ERROR,
                        message="Parse error"
                    )
                )
            
            # 验证JSON-RPC 2.0格式
            if not isinstance(data, dict) or data.get("jsonrpc") != "2.0":
                return JsonRpcResponse(
                    id=data.get("id") if isinstance(data, dict) else None,
                    error=JsonRpcError(
                        code=self.INVALID_REQUEST,
                        message="Invalid Request"
                    )
                )
            
            method = data.get("method")
            params = data.get("params", {})
            msg_id = data.get("id")
            
            # 如果没有id字段，这是一个通知消息，不需要响应
            if msg_id is None:
                self._handle_notification(method, params)
                return None
            
            # 处理请求消息
            return self._handle_request(method, params, msg_id)
            
        except Exception as e:
            self.logger.error(f"处理消息时发生内部错误: {e}")
            return JsonRpcResponse(
                id=data.get("id") if "data" in locals() and isinstance(data, dict) else None,
                error=JsonRpcError(
                    code=self.INTERNAL_ERROR,
                    message="Internal error",
                    data=str(e)
                )
            )
    
    def _handle_notification(self, method: str, params: Dict[str, Any]) -> None:
        """处理通知消息（无需响应）.
        
        Args:
            method: 通知方法名
            params: 通知参数
        """
        self.logger.debug(f"收到通知: {method}")
        # 通知消息通常用于客户端向服务器发送状态更新等信息
        # 这里可以根据需要处理特定的通知消息
    
    def _handle_request(self, method: str, params: Dict[str, Any], msg_id: Union[str, int]) -> JsonRpcResponse:
        """
        处理请求消息
        
        Args:
            method: 方法名
            params: 参数
            msg_id: 消息ID
            
        Returns:
            响应对象
        """
        try:
            # 处理标准MCP方法
            if method == "initialize":
                return self._handle_initialize(params, msg_id)
            elif method == "ping":
                return self._handle_ping(params, msg_id)
            elif method == "tools/list":
                return self._handle_tools_list(params, msg_id)
            elif method == "tools/call":
                return self._handle_tools_call(params, msg_id)
            else:
                return JsonRpcResponse(
                    id=msg_id,
                    error=JsonRpcError(
                        code=self.METHOD_NOT_FOUND,
                        message=f"Method not found: {method}"
                    )
                )
        except Exception as e:
            self.logger.error(f"处理请求 {method} 时发生错误: {e}")
            return JsonRpcResponse(
                id=msg_id,
                error=JsonRpcError(
                    code=self.INTERNAL_ERROR,
                    message="Internal error",
                    data=str(e)
                )
            )
    
    def _handle_initialize(self, params: Dict[str, Any], msg_id: Union[str, int]) -> JsonRpcResponse:
        """处理初始化请求.
        
        Args:
            params: 初始化参数
            msg_id: 消息ID
            
        Returns:
            包含服务器能力信息的响应对象
        """
        self.initialized = True
        self.logger.info("MCP服务器已初始化")
        
        return JsonRpcResponse(
            id=msg_id,
            result={
                "protocolVersion": "2024-11-05",
                "capabilities": {
                    "tools": {}
                },
                "serverInfo": {
                    "name": self.tool_name,
                    "version": "1.0.0"
                }
            }
        )
    
    def _handle_ping(self, params: Dict[str, Any], msg_id: Union[str, int]) -> JsonRpcResponse:
        """处理ping请求.
        
        Args:
            params: ping参数（通常为空）
            msg_id: 消息ID
            
        Returns:
            空结果的响应对象
        """
        return JsonRpcResponse(
            id=msg_id,
            result={}
        )
    
    def _handle_tools_list(self, params: Dict[str, Any], msg_id: Union[str, int]) -> JsonRpcResponse:
        """处理工具列表请求.
        
        Args:
            params: 请求参数（通常为空）
            msg_id: 消息ID
            
        Returns:
            包含所有可用工具列表的响应对象
        """
        tools_list = []
        
        for tool_name in self.tools.keys():
            tool_info = {
                "name": tool_name,
                "description": self._get_tool_description(tool_name),
                "inputSchema": {
                    "type": "object",
                    "properties": self._get_tool_input_schema(tool_name),
                    "required": self._get_tool_required_params(tool_name)
                }
            }
            tools_list.append(tool_info)
        
        return JsonRpcResponse(
            id=msg_id,
            result={
                "tools": tools_list
            }
        )
    
    def _handle_tools_call(self, params: Dict[str, Any], msg_id: Union[str, int]) -> JsonRpcResponse:
        """处理工具调用请求.
        
        Args:
            params: 工具调用参数，包含name和arguments
            msg_id: 消息ID
            
        Returns:
            包含工具执行结果的响应对象
        """
        if not self.initialized:
            return JsonRpcResponse(
                id=msg_id,
                error=JsonRpcError(
                    code=self.INVALID_REQUEST,
                    message="Server not initialized"
                )
            )
        
        tool_name = params.get("name")
        arguments = params.get("arguments", {})
        
        if tool_name not in self.tools:
            return JsonRpcResponse(
                id=msg_id,
                error=JsonRpcError(
                    code=self.METHOD_NOT_FOUND,
                    message=f"Tool not found: {tool_name}"
                )
            )
        
        try:
            # 调用具体的工具实现
            result = self.tools[tool_name](arguments)
            
            return JsonRpcResponse(
                id=msg_id,
                result={
                    "content": [
                        {
                            "type": "text",
                            "text": result
                        }
                    ]
                }
            )
            
        except Exception as e:
            self.logger.error(f"工具 {tool_name} 执行失败: {e}")
            return JsonRpcResponse(
                id=msg_id,
                error=JsonRpcError(
                    code=self.INTERNAL_ERROR,
                    message=f"Tool execution failed: {str(e)}"
                )
            )
    
    def _send_response(self, response: JsonRpcResponse) -> None:
        """发送响应到标准输出.
        
        Args:
            response: 要发送的JSON-RPC响应对象
        """
        try:
            # 将响应对象转换为字典，过滤None值
            response_dict = asdict(response)
            response_dict = {k: v for k, v in response_dict.items() if v is not None}
            
            # 处理嵌套的dataclass对象
            if response.error:
                response_dict["error"] = asdict(response.error)
                response_dict["error"] = {k: v for k, v in response_dict["error"].items() if v is not None}
            
            # 发送JSON响应
            json_response = json.dumps(response_dict, ensure_ascii=False)
            print(json_response, flush=True)
            
        except Exception as e:
            self.logger.error(f"发送响应失败: {e}")
    
    def _get_tool_description(self, tool_name: str) -> str:
        """获取工具描述.
        
        Args:
            tool_name: 工具名称
            
        Returns:
            工具描述文本
        """
        descriptions = {
            "listEndpoints": "列出所有可用的API端点，提供端点概览和统计信息",
            "searchEndpoints": "根据关键字、标签、方法或路径模式搜索API端点",
            "getEndpointDetails": "获取指定API端点的详细信息，包括参数、请求体和响应格式",
            "listSchemas": "列出所有可用的数据模式(Schema)定义",
            "getSchemaDetails": "获取指定数据模式(Schema)的详细定义信息"
        }
        return descriptions.get(tool_name, "")
    
    def _get_tool_input_schema(self, tool_name: str) -> Dict[str, Any]:
        """获取工具输入参数模式.
        
        Args:
            tool_name: 工具名称
            
        Returns:
            工具输入参数的JSON Schema定义
        """
        schemas = {
            "listEndpoints": {},
            "searchEndpoints": {
                "keyword": {
                    "type": "string",
                    "description": "搜索关键字，在端点路径、描述和摘要中查找"
                },
                "tag": {
                    "type": "string", 
                    "description": "按标签过滤端点"
                },
                "method": {
                    "type": "string",
                    "description": "按HTTP方法过滤端点 (GET, POST, PUT, DELETE等)"
                },
                "path_pattern": {
                    "type": "string",
                    "description": "路径正则表达式模式"
                }
            },
            "getEndpointDetails": {
                "endpoint_id": {
                    "type": "string",
                    "description": "端点ID (method+path格式，如 'GET /users') 或者分别提供method和path参数"
                },
                "method": {
                    "type": "string",
                    "description": "HTTP方法，与path一起使用"
                },
                "path": {
                    "type": "string", 
                    "description": "API路径，与method一起使用"
                }
            },
            "listSchemas": {},
            "getSchemaDetails": {
                "schema_name": {
                    "type": "string",
                    "description": "要查询的Schema名称"
                }
            }
        }
        return schemas.get(tool_name, {})
    
    def _get_tool_required_params(self, tool_name: str) -> List[str]:
        """获取工具必需参数列表.
        
        Args:
            tool_name: 工具名称
            
        Returns:
            必需参数名称列表
        """
        required = {
            "listEndpoints": [],
            "searchEndpoints": [],
            "getEndpointDetails": [],  # endpoint_id 或 (method + path) 至少需要一个
            "listSchemas": [],
            "getSchemaDetails": ["schema_name"]
        }
        return required.get(tool_name, [])
    
    # 工具方法实现
    def _handle_list_endpoints(self, arguments: Dict[str, Any]) -> str:
        """处理listEndpoints工具调用.
        
        Args:
            arguments: 工具参数（此工具无需参数）
            
        Returns:
            格式化的端点概览文本
        """
        return list_endpoints.format_endpoints_overview(self.service_model)
    
    def _handle_search_endpoints(self, arguments: Dict[str, Any]) -> str:
        """处理searchEndpoints工具调用.
        
        Args:
            arguments: 搜索参数，包含keyword、tag、method、path_pattern等
            
        Returns:
            格式化的搜索结果文本
        """
        keyword = arguments.get("keyword", "")
        tag = arguments.get("tag", "")
        method = arguments.get("method", "")
        path_pattern = arguments.get("path_pattern", "")
        
        search_params = {
            "keyword": keyword,
            "tag": tag,
            "method": method,
            "path_pattern": path_pattern
        }
        
        results = search_endpoints.search_endpoints(self.service_model, search_params)
        return search_endpoints.format_search_results(results, search_params)
    
    def _handle_get_endpoint_details(self, arguments: Dict[str, Any]) -> str:
        """处理getEndpointDetails工具调用.
        
        Args:
            arguments: 端点查询参数，支持endpoint_id或method+path组合
            
        Returns:
            格式化的端点详细信息文本
        """
        endpoint_id = arguments.get("endpoint_id", "")
        method = arguments.get("method", "")
        path = arguments.get("path", "")
        
        if endpoint_id:
            # 使用endpoint_id查找
            endpoint, found = get_endpoint_details.get_endpoint_details(
                self.service_model, endpoint_id
            )
        elif method and path:
            # 使用method和path查找
            endpoint, found = get_endpoint_details.get_endpoint_details(
                self.service_model, method, path
            )
        else:
            return "错误：必须提供 endpoint_id 或 (method + path) 参数"
        
        if not found:
            return f"未找到端点: {endpoint_id or f'{method} {path}'}"
        
        return get_endpoint_details.format_endpoint_details(endpoint, self.service_model)
    
    def _handle_list_schemas(self, arguments: Dict[str, Any]) -> str:
        """处理listSchemas工具调用.
        
        Args:
            arguments: 工具参数（此工具无需参数）
            
        Returns:
            格式化的Schema列表文本
        """
        schemas = list_schemas.list_schemas(self.service_model)
        return list_schemas.format_schemas_list(schemas)
    
    def _handle_get_schema_details(self, arguments: Dict[str, Any]) -> str:
        """处理getSchemaDetails工具调用.
        
        Args:
            arguments: Schema查询参数，必须包含schema_name
            
        Returns:
            格式化的Schema详细信息文本
        """
        schema_name = arguments.get("schema_name", "")
        
        if not schema_name:
            return "错误：必须提供 schema_name 参数"
        
        schema, found = get_schema_details.get_schema_details(
            self.service_model, schema_name
        )
        
        if not found:
            return f"未找到Schema: {schema_name}"
        
        return get_schema_details.format_schema_details(schema, self.service_model)
`

// MethodsInitPyTemplate methods/__init__.py方法导出模板
const MethodsInitPyTemplate = `"""
MCP 工具方法实现包
提供所有 API 查询和文档功能

Generated by swagger2mcp  
"""

from .list_endpoints import format_endpoints_overview
from .search_endpoints import search_endpoints, format_search_results
from .get_endpoint_details import get_endpoint_details, format_endpoint_details
from .list_schemas import list_schemas, format_schemas_list
from .get_schema_details import get_schema_details, format_schema_details

__all__ = [
    'format_endpoints_overview',
    'search_endpoints',
    'format_search_results',
    'get_endpoint_details', 
    'format_endpoint_details',
    'list_schemas',
    'format_schemas_list',
    'get_schema_details',
    'format_schema_details'
]
`

// ListEndpointsPyTemplate list_endpoints.py模板
const ListEndpointsPyTemplate = `"""
列出所有API端点的实现
提供端点概览、统计信息和格式化显示

Generated by swagger2mcp
"""

from typing import List, Dict, Any, Counter
from {{.PackageName}}.spec.model import ServiceModel, EndpointModel


def format_endpoints_overview(service_model: ServiceModel) -> str:
    """
    格式化API端点概览信息
    
    Args:
        service_model: 服务模型
        
    Returns:
        格式化的概览文本
    """
    if not service_model or not service_model.endpoints:
        return "## 📋 API 接口概览\n\n暂无可用的API端点。"
    
    # 统计信息
    total_endpoints = len(service_model.endpoints)
    method_stats = {}
    tag_stats = {}
    
    for endpoint in service_model.endpoints:
        # 统计HTTP方法
        method = endpoint.method.upper()
        method_stats[method] = method_stats.get(method, 0) + 1
        
        # 统计标签
        for tag in endpoint.tags:
            tag_stats[tag] = tag_stats.get(tag, 0) + 1
    
    # 构建概览文本
    overview = []
    overview.append("## 📋 API 接口概览")
    overview.append("")
    overview.append(f"**服务名称**: {service_model.title}")
    overview.append(f"**版本**: {service_model.version}")
    
    if service_model.description:
        overview.append(f"**描述**: {service_model.description}")
    
    # 服务器信息
    if service_model.servers:
        overview.append("")
        overview.append("### 🌐 服务器")
        for i, server in enumerate(service_model.servers):
            overview.append(f"{i+1}. **{server.url}**")
            if server.description:
                overview.append(f"   - {server.description}")
    
    # 统计信息
    overview.append("")
    overview.append("### 📊 接口统计")
    overview.append(f"**总计**: {total_endpoints} 个接口")
    
    # HTTP方法统计
    if method_stats:
        overview.append("")
        overview.append("**按方法分类**:")
        for method, count in sorted(method_stats.items()):
            emoji = _get_method_emoji(method)
            overview.append(f"- {emoji} {method}: {count} 个")
    
    # 标签统计
    if tag_stats:
        overview.append("")
        overview.append("**按标签分类**:")
        for tag, count in sorted(tag_stats.items(), key=lambda x: x[1], reverse=True):
            overview.append(f"- 🏷️ {tag}: {count} 个")
    
    # 端点列表
    overview.append("")
    overview.append("### 📝 接口列表")
    overview.append("")
    
    # 按标签分组显示端点
    endpoints_by_tag = {}
    untagged_endpoints = []
    
    for endpoint in service_model.endpoints:
        if endpoint.tags:
            for tag in endpoint.tags:
                if tag not in endpoints_by_tag:
                    endpoints_by_tag[tag] = []
                endpoints_by_tag[tag].append(endpoint)
        else:
            untagged_endpoints.append(endpoint)
    
    # 显示有标签的端点
    for tag in sorted(endpoints_by_tag.keys()):
        overview.append(f"#### 🏷️ {tag}")
        overview.append("")
        endpoints = endpoints_by_tag[tag]
        for endpoint in sorted(endpoints, key=lambda e: (e.method, e.path)):
            overview.append(_format_endpoint_line(endpoint))
        overview.append("")
    
    # 显示无标签的端点
    if untagged_endpoints:
        overview.append("#### 📂 其他接口")
        overview.append("")
        for endpoint in sorted(untagged_endpoints, key=lambda e: (e.method, e.path)):
            overview.append(_format_endpoint_line(endpoint))
        overview.append("")
    
    # Schema信息
    if service_model.schemas:
        overview.append("### 📋 数据模型")
        overview.append(f"**可用Schema**: {len(service_model.schemas)} 个")
        schema_names = sorted(service_model.schemas.keys())[:10]  # 只显示前10个
        for name in schema_names:
            overview.append(f"- 📄 {name}")
        if len(service_model.schemas) > 10:
            overview.append(f"- ... 还有 {len(service_model.schemas) - 10} 个")
    
    overview.append("")
    overview.append("---")
    overview.append("💡 **提示**: 使用 ` + "`" + `searchEndpoints` + "`" + ` 搜索特定接口，使用 ` + "`" + `getEndpointDetails` + "`" + ` 查看接口详情")
    
    return "\n".join(overview)


def _get_method_emoji(method: str) -> str:
    """获取HTTP方法对应的emoji"""
    emojis = {
        "GET": "🔍",
        "POST": "➕", 
        "PUT": "✏️",
        "PATCH": "🔧",
        "DELETE": "🗑️",
        "HEAD": "👁️",
        "OPTIONS": "⚙️",
        "TRACE": "🔄"
    }
    return emojis.get(method.upper(), "📡")


def _format_endpoint_line(endpoint: EndpointModel) -> str:
    """格式化单个端点行"""
    emoji = _get_method_emoji(endpoint.method)
    method = endpoint.method.upper()
    path = endpoint.path
    summary = endpoint.summary or "无描述"
    
    # 限制摘要长度
    if len(summary) > 50:
        summary = summary[:47] + "..."
    
    return f"- {emoji} **{method}** ` + "`" + `{path}` + "`" + ` - {summary}"
`

// SearchEndpointsPyTemplate search_endpoints.py模板
const SearchEndpointsPyTemplate = `"""
搜索API端点的实现
支持关键字、标签、方法、路径模式搜索

Generated by swagger2mcp
"""

import re
from typing import List, Dict, Any, Optional
from {{.PackageName}}.spec.model import ServiceModel, EndpointModel


def search_endpoints(service_model: ServiceModel, search_params: Dict[str, str]) -> List[Dict[str, Any]]:
    """
    搜索API端点
    
    Args:
        service_model: 服务模型
        search_params: 搜索参数，包含keyword, tag, method, path_pattern
        
    Returns:
        匹配的端点列表，每个端点包含基本信息
    """
    if not service_model or not service_model.endpoints:
        return []
    
    keyword = search_params.get("keyword", "").strip().lower()
    tag_filter = search_params.get("tag", "").strip().lower()
    method_filter = search_params.get("method", "").strip().lower()
    path_pattern = search_params.get("path_pattern", "").strip()
    
    results = []
    
    # 编译正则表达式（如果提供了路径模式）
    path_regex = None
    if path_pattern:
        try:
            path_regex = re.compile(path_pattern, re.IGNORECASE)
        except re.error:
            # 如果正则表达式无效，将其作为普通字符串处理
            path_regex = None
            keyword = path_pattern.lower()
    
    for endpoint in service_model.endpoints:
        if _matches_filters(endpoint, keyword, tag_filter, method_filter, path_regex):
            results.append(_endpoint_to_dict(endpoint))
    
    return results


def _matches_filters(endpoint: EndpointModel, keyword: str, tag_filter: str, 
                    method_filter: str, path_regex: Optional[re.Pattern]) -> bool:
    """检查端点是否匹配搜索条件"""
    
    # 方法过滤
    if method_filter and endpoint.method.lower() != method_filter:
        return False
    
    # 标签过滤
    if tag_filter:
        tag_matches = any(tag_filter in tag.lower() for tag in endpoint.tags)
        if not tag_matches:
            return False
    
    # 路径正则表达式匹配
    if path_regex:
        if not path_regex.search(endpoint.path):
            return False
    
    # 关键字搜索（在路径、摘要、描述中查找）
    if keyword:
        search_text = " ".join([
            endpoint.path.lower(),
            endpoint.summary.lower() if endpoint.summary else "",
            endpoint.description.lower() if endpoint.description else "",
            " ".join(endpoint.tags).lower()
        ])
        
        if keyword not in search_text:
            return False
    
    return True


def _endpoint_to_dict(endpoint: EndpointModel) -> Dict[str, Any]:
    """将端点模型转换为字典格式"""
    return {
        "id": endpoint.id,
        "method": endpoint.method.upper(),
        "path": endpoint.path,
        "summary": endpoint.summary or "",
        "description": endpoint.description or "",
        "tags": endpoint.tags or [],
        "has_parameters": len(endpoint.parameters) > 0,
        "has_request_body": endpoint.request_body is not None,
        "has_responses": len(endpoint.responses) > 0
    }


def format_search_results(results: List[Dict[str, Any]], search_params: Dict[str, str]) -> str:
    """
    格式化搜索结果
    
    Args:
        results: 搜索结果列表
        search_params: 搜索参数
        
    Returns:
        格式化的搜索结果文本
    """
    if not results:
        return _format_no_results(search_params)
    
    output = []
    output.append("## 🔍 接口搜索结果")
    output.append("")
    
    # 显示搜索条件
    conditions = _format_search_conditions(search_params)
    if conditions:
        output.append(f"**搜索条件**: {conditions}")
        output.append("")
    
    output.append(f"**找到 {len(results)} 个匹配的接口**")
    output.append("")
    
    # 按方法分组显示结果
    results_by_method = {}
    for result in results:
        method = result["method"]
        if method not in results_by_method:
            results_by_method[method] = []
        results_by_method[method].append(result)
    
    for method in sorted(results_by_method.keys()):
        endpoints = results_by_method[method]
        emoji = _get_method_emoji(method)
        output.append(f"### {emoji} {method} ({len(endpoints)} 个)")
        output.append("")
        
        for endpoint in sorted(endpoints, key=lambda e: e["path"]):
            output.append(_format_result_item(endpoint))
        output.append("")
    
    output.append("---")
    output.append("💡 **提示**: 使用 ` + "`" + `getEndpointDetails` + "`" + ` 查看接口详情")
    
    return "\n".join(output)


def _format_search_conditions(search_params: Dict[str, str]) -> str:
    """格式化搜索条件"""
    conditions = []
    
    if search_params.get("keyword"):
        conditions.append(f"关键字='{search_params['keyword']}'")
    if search_params.get("tag"):
        conditions.append(f"标签='{search_params['tag']}'")
    if search_params.get("method"):
        conditions.append(f"方法={search_params['method'].upper()}")
    if search_params.get("path_pattern"):
        conditions.append(f"路径模式='{search_params['path_pattern']}'")
    
    return ", ".join(conditions)


def _format_no_results(search_params: Dict[str, str]) -> str:
    """格式化无结果消息"""
    conditions = _format_search_conditions(search_params)
    output = []
    output.append("## 🔍 接口搜索结果")
    output.append("")
    
    if conditions:
        output.append(f"**搜索条件**: {conditions}")
        output.append("")
    
    output.append("❌ **未找到匹配的接口**")
    output.append("")
    output.append("**建议**:")
    output.append("- 检查搜索条件是否正确")
    output.append("- 尝试使用更宽泛的关键字")
    output.append("- 使用 ` + "`" + `listEndpoints` + "`" + ` 查看所有可用接口")
    
    return "\n".join(output)


def _format_result_item(endpoint: Dict[str, Any]) -> str:
    """格式化单个搜索结果项"""
    path = endpoint["path"]
    summary = endpoint["summary"] or "无描述"
    tags = endpoint["tags"]
    
    # 限制摘要长度
    if len(summary) > 60:
        summary = summary[:57] + "..."
    
    result = f"- ` + "`" + `{path}` + "`" + ` - {summary}"
    
    # 添加标签信息
    if tags:
        tag_str = ", ".join(tags[:3])  # 最多显示3个标签
        if len(tags) > 3:
            tag_str += f" (+{len(tags)-3})"
        result += f" [🏷️ {tag_str}]"
    
    # 添加功能标识
    features = []
    if endpoint["has_parameters"]:
        features.append("📝参数")
    if endpoint["has_request_body"]:  
        features.append("📤请求体")
    if endpoint["has_responses"]:
        features.append("📥响应")
    
    if features:
        result += f" ({', '.join(features)})"
    
    return result


def _get_method_emoji(method: str) -> str:
    """获取HTTP方法对应的emoji"""
    emojis = {
        "GET": "🔍",
        "POST": "➕",
        "PUT": "✏️", 
        "PATCH": "🔧",
        "DELETE": "🗑️",
        "HEAD": "👁️",
        "OPTIONS": "⚙️",
        "TRACE": "🔄"
    }
    return emojis.get(method.upper(), "📡")
`

// GetEndpointDetailsPyTemplate get_endpoint_details.py模板
const GetEndpointDetailsPyTemplate = `"""
获取API端点详细信息的实现
支持通过ID或method+path查找端点详情

Generated by swagger2mcp
"""

from typing import Tuple, Optional, List, Dict, Any
from {{.PackageName}}.spec.model import ServiceModel, EndpointModel, SchemaOrRef, ParameterModel, ResponseModel


def get_endpoint_details(service_model: ServiceModel, *args) -> Tuple[Optional[EndpointModel], bool]:
    """
    获取端点详细信息
    
    Args:
        service_model: 服务模型
        *args: 可以是 (endpoint_id,) 或 (method, path)
        
    Returns:
        (端点模型或None, 是否找到)
    """
    if not service_model or not service_model.endpoints:
        return None, False
    
    if len(args) == 1:
        # 通过endpoint_id查找
        endpoint_id = args[0].strip()
        for endpoint in service_model.endpoints:
            if endpoint.id == endpoint_id:
                return endpoint, True
    elif len(args) == 2:
        # 通过method和path查找
        method = args[0].strip().lower()
        path = args[1].strip()
        for endpoint in service_model.endpoints:
            if endpoint.method.lower() == method and endpoint.path == path:
                return endpoint, True
    
    return None, False


def format_endpoint_details(endpoint: EndpointModel, service_model: ServiceModel) -> str:
    """
    格式化端点详细信息
    
    Args:
        endpoint: 端点模型
        service_model: 服务模型（用于解析Schema引用）
        
    Returns:
        格式化的详细信息文本
    """
    output = []
    
    # 标题和基本信息
    emoji = _get_method_emoji(endpoint.method)
    method = endpoint.method.upper()
    output.append(f"## {emoji} {method} {endpoint.path}")
    output.append("")
    
    if endpoint.summary:
        output.append(f"**摘要**: {endpoint.summary}")
    
    if endpoint.description:
        output.append(f"**描述**: {endpoint.description}")
        
    # 标签
    if endpoint.tags:
        tags_str = " ".join([f"` + "`" + `{tag}` + "`" + `" for tag in endpoint.tags])
        output.append(f"**标签**: {tags_str}")
    
    output.append(f"**端点ID**: ` + "`" + `{endpoint.id}` + "`" + `")
    output.append("")
    
    # 参数
    if endpoint.parameters:
        output.append("### 📝 请求参数")
        output.append("")
        output.extend(_format_parameters(endpoint.parameters, service_model))
        output.append("")
    
    # 请求体
    if endpoint.request_body:
        output.append("### 📤 请求体")
        output.append("")
        output.extend(_format_request_body(endpoint.request_body, service_model))
        output.append("")
    
    # 响应
    if endpoint.responses:
        output.append("### 📥 响应")
        output.append("")
        output.extend(_format_responses(endpoint.responses, service_model))
        output.append("")
    
    output.append("---")
    output.append("💡 **提示**: 使用 ` + "`" + `listSchemas` + "`" + ` 查看可用的数据模型")
    
    return "\n".join(output)


def _format_parameters(parameters: List[ParameterModel], service_model: ServiceModel) -> List[str]:
    """格式化参数列表"""
    output = []
    
    # 按位置分组
    params_by_location = {}
    for param in parameters:
        location = param.in_
        if location not in params_by_location:
            params_by_location[location] = []
        params_by_location[location].append(param)
    
    # 按位置顺序显示
    location_order = ["path", "query", "header", "cookie"]
    location_names = {
        "path": "🛤️ 路径参数",
        "query": "❓ 查询参数", 
        "header": "📋 请求头参数",
        "cookie": "🍪 Cookie参数"
    }
    
    for location in location_order:
        if location in params_by_location:
            params = params_by_location[location]
            output.append(f"#### {location_names[location]}")
            output.append("")
            
            for param in params:
                required_indicator = " *(必需)*" if param.required else " *(可选)*"
                output.append(f"- **{param.name}**{required_indicator}")
                
                if param.schema:
                    schema_info = _format_schema_info(param.schema, service_model)
                    if schema_info:
                        output.append(f"  - {schema_info}")
                
                output.append("")
    
    return output


def _format_request_body(request_body, service_model: ServiceModel) -> List[str]:
    """格式化请求体信息"""
    output = []
    
    required_text = "**必需**" if request_body.required else "**可选**"
    output.append(f"**是否必需**: {required_text}")
    output.append("")
    
    if request_body.content:
        output.append("**支持的内容类型**:")
        output.append("")
        
        for i, media in enumerate(request_body.content):
            output.append(f"{i+1}. **{media.mime}**")
            
            if media.schema:
                schema_info = _format_schema_info(media.schema, service_model)
                if schema_info:
                    output.append(f"   - {schema_info}")
            
            if media.example is not None:
                output.append(f"   - 示例: ` + "`" + `{_format_example(media.example)}` + "`" + `")
            
            output.append("")
    
    return output


def _format_responses(responses: List[ResponseModel], service_model: ServiceModel) -> List[str]:
    """格式化响应信息"""
    output = []
    
    for response in sorted(responses, key=lambda r: r.status):
        status_emoji = _get_status_emoji(response.status)
        output.append(f"#### {status_emoji} {response.status}")
        output.append("")
        
        if response.description:
            output.append(f"**描述**: {response.description}")
            output.append("")
        
        if response.content:
            output.append("**响应内容**:")
            output.append("")
            
            for i, media in enumerate(response.content):
                output.append(f"{i+1}. **{media.mime}**")
                
                if media.schema:
                    schema_info = _format_schema_info(media.schema, service_model)
                    if schema_info:
                        output.append(f"   - {schema_info}")
                
                if media.example is not None:
                    output.append(f"   - 示例: ` + "`" + `{_format_example(media.example)}` + "`" + `")
                
                output.append("")
        
        output.append("")
    
    return output


def _format_schema_info(schema_or_ref: SchemaOrRef, service_model: ServiceModel) -> str:
    """格式化Schema信息"""
    if schema_or_ref.ref:
        # 这是一个引用
        ref_name = schema_or_ref.ref.ref.replace("#/components/schemas/", "")
        if ref_name in service_model.schemas:
            schema = service_model.schemas[ref_name]
            return f"类型: ` + "`" + `{schema.type or 'object'}` + "`" + ` (引用: {ref_name})"
        else:
            return f"类型: 引用 {ref_name} (未找到定义)"
    elif schema_or_ref.schema:
        # 直接的Schema定义
        schema = schema_or_ref.schema
        schema_type = schema.type or "unknown"
        
        info_parts = [f"类型: ` + "`" + `{schema_type}` + "`" + `"]
        
        if schema.format:
            info_parts.append(f"格式: ` + "`" + `{schema.format}` + "`" + `")
        
        if schema.enum:
            enum_values = ", ".join([str(v) for v in schema.enum[:3]])
            if len(schema.enum) > 3:
                enum_values += f" (+{len(schema.enum)-3})"
            info_parts.append(f"枚举: {enum_values}")
        
        if schema.description:
            desc = schema.description
            if len(desc) > 50:
                desc = desc[:47] + "..."
            info_parts.append(f"说明: {desc}")
        
        return " | ".join(info_parts)
    
    return "类型: 未知"


def _format_example(example: Any) -> str:
    """格式化示例值"""
    if example is None:
        return "null"
    elif isinstance(example, str):
        return f'"{example}"' if len(str(example)) < 50 else f'"{str(example)[:47]}..."'
    elif isinstance(example, (dict, list)):
        example_str = str(example)
        return example_str if len(example_str) < 100 else f"{example_str[:97]}..."
    else:
        return str(example)


def _get_method_emoji(method: str) -> str:
    """获取HTTP方法对应的emoji"""
    emojis = {
        "GET": "🔍",
        "POST": "➕",
        "PUT": "✏️",
        "PATCH": "🔧", 
        "DELETE": "🗑️",
        "HEAD": "👁️",
        "OPTIONS": "⚙️",
        "TRACE": "🔄"
    }
    return emojis.get(method.upper(), "📡")


def _get_status_emoji(status: str) -> str:
    """获取HTTP状态码对应的emoji"""
    if status.startswith("2"):
        return "✅"
    elif status.startswith("3"):
        return "🔄"
    elif status.startswith("4"):
        return "❌"
    elif status.startswith("5"):
        return "💥"
    else:
        return "📡"
`

// ListSchemasPyTemplate list_schemas.py模板
const ListSchemasPyTemplate = `"""
列出数据模式(Schema)的实现
提供Schema摘要信息和列表显示

Generated by swagger2mcp
"""

from typing import List, Dict, Any
from {{.PackageName}}.spec.model import ServiceModel, Schema


def list_schemas(service_model: ServiceModel) -> List[Dict[str, Any]]:
    """
    获取所有Schema的摘要信息
    
    Args:
        service_model: 服务模型
        
    Returns:
        Schema信息列表
    """
    if not service_model or not service_model.schemas:
        return []
    
    schemas = []
    for name, schema in service_model.schemas.items():
        schema_info = {
            "name": name,
            "type": schema.type or "object",
            "description": schema.description or "",
            "has_properties": bool(schema.properties),
            "property_count": len(schema.properties) if schema.properties else 0,
            "has_enum": bool(schema.enum),
            "enum_count": len(schema.enum) if schema.enum else 0,
            "has_example": schema.example is not None,
            "format": schema.format or "",
            "required_fields": len(schema.required) if schema.required else 0
        }
        schemas.append(schema_info)
    
    # 按名称排序
    return sorted(schemas, key=lambda s: s["name"])


def format_schemas_list(schemas: List[Dict[str, Any]]) -> str:
    """
    格式化Schema列表显示
    
    Args:
        schemas: Schema信息列表
        
    Returns:
        格式化的Schema列表文本
    """
    if not schemas:
        return "## 📋 数据模型列表\n\n❌ **暂无可用的数据模型定义**"
    
    output = []
    output.append("## 📋 数据模型 (Schema) 列表")
    output.append("")
    output.append(f"**总计**: {len(schemas)} 个数据模型")
    output.append("")
    
    # 按类型分组统计
    type_stats = {}
    for schema in schemas:
        schema_type = schema["type"]
        type_stats[schema_type] = type_stats.get(schema_type, 0) + 1
    
    if len(type_stats) > 1:
        output.append("**按类型分类**:")
        for schema_type, count in sorted(type_stats.items()):
            emoji = _get_type_emoji(schema_type)
            output.append(f"- {emoji} {schema_type}: {count} 个")
        output.append("")
    
    # 详细列表
    output.append("### 📝 详细列表")
    output.append("")
    
    # 按类型分组显示
    schemas_by_type = {}
    for schema in schemas:
        schema_type = schema["type"]
        if schema_type not in schemas_by_type:
            schemas_by_type[schema_type] = []
        schemas_by_type[schema_type].append(schema)
    
    for schema_type in sorted(schemas_by_type.keys()):
        type_schemas = schemas_by_type[schema_type]
        emoji = _get_type_emoji(schema_type)
        
        output.append(f"#### {emoji} {schema_type.title()} 类型 ({len(type_schemas)} 个)")
        output.append("")
        
        for schema in sorted(type_schemas, key=lambda s: s["name"]):
            output.append(_format_schema_item(schema))
        output.append("")
    
    output.append("---")
    output.append("💡 **提示**: 使用 ` + "`" + `getSchemaDetails` + "`" + ` 查看具体Schema的详细定义")
    
    return "\n".join(output)


def _format_schema_item(schema: Dict[str, Any]) -> str:
    """格式化单个Schema项目"""
    name = schema["name"]
    description = schema["description"]
    
    # 基本信息
    result = f"- **{name}**"
    
    # 描述
    if description:
        desc = description
        if len(desc) > 60:
            desc = desc[:57] + "..."
        result += f" - {desc}"
    
    # 属性统计
    details = []
    
    if schema["has_properties"] and schema["property_count"] > 0:
        details.append(f"{schema['property_count']} 属性")
    
    if schema["required_fields"] > 0:
        details.append(f"{schema['required_fields']} 必需")
    
    if schema["has_enum"]:
        details.append(f"{schema['enum_count']} 枚举值")
    
    if schema["format"]:
        details.append(f"格式: {schema['format']}")
    
    if schema["has_example"]:
        details.append("有示例")
    
    if details:
        result += f" [{', '.join(details)}]"
    
    return result


def _get_type_emoji(schema_type: str) -> str:
    """获取Schema类型对应的emoji"""
    emojis = {
        "object": "📦",
        "array": "📋",
        "string": "📝",
        "number": "🔢",
        "integer": "🔢",
        "boolean": "☑️",
        "null": "⚫"
    }
    return emojis.get(schema_type.lower(), "📄")
`

// GetSchemaDetailsPyTemplate get_schema_details.py模板
const GetSchemaDetailsPyTemplate = `"""
获取数据模式(Schema)详细信息的实现  
支持递归解析Schema引用和复杂结构

Generated by swagger2mcp
"""

from typing import Tuple, Optional, List, Dict, Any, Set
from {{.PackageName}}.spec.model import ServiceModel, Schema, SchemaOrRef


def get_schema_details(service_model: ServiceModel, schema_name: str) -> Tuple[Optional[Schema], bool]:
    """
    获取指定Schema的详细信息
    
    Args:
        service_model: 服务模型
        schema_name: Schema名称
        
    Returns:
        (Schema对象或None, 是否找到)
    """
    if not service_model or not service_model.schemas:
        return None, False
    
    schema_name = schema_name.strip()
    if schema_name in service_model.schemas:
        return service_model.schemas[schema_name], True
    
    return None, False


def format_schema_details(schema: Schema, service_model: ServiceModel) -> str:
    """
    格式化Schema详细信息
    
    Args:
        schema: Schema对象
        service_model: 服务模型（用于解析引用）
        
    Returns:
        格式化的详细信息文本
    """
    output = []
    visited_refs = set()  # 避免循环引用
    
    # 标题和基本信息
    emoji = _get_type_emoji(schema.type or "object")
    output.append(f"## {emoji} {schema.name}")
    output.append("")
    
    if schema.description:
        output.append(f"**描述**: {schema.description}")
        output.append("")
    
    # 基本类型信息
    output.append("### ℹ️ 基本信息")
    output.append("")
    output.append(f"- **类型**: ` + "`" + `{schema.type or 'object'}` + "`" + `")
    
    if schema.format:
        output.append(f"- **格式**: ` + "`" + `{schema.format}` + "`" + `")
    
    if schema.example is not None:
        output.append(f"- **示例**: ` + "`" + `{_format_example(schema.example)}` + "`" + `")
    
    output.append("")
    
    # 枚举值
    if schema.enum:
        output.append("### 📝 枚举值")
        output.append("")
        for i, value in enumerate(schema.enum):
            output.append(f"{i+1}. ` + "`" + `{value}` + "`" + `")
        output.append("")
    
    # 属性
    if schema.properties:
        output.append("### 📦 属性")
        output.append("")
        output.extend(_format_properties(schema, service_model, visited_refs, level=0))
        output.append("")
    
    # 数组项目
    if schema.items:
        output.append("### 📋 数组项目类型")
        output.append("")
        output.extend(_format_schema_or_ref(schema.items, service_model, visited_refs, level=0))
        output.append("")
    
    # 组合Schema (allOf, anyOf, oneOf)
    if schema.all_of:
        output.append("### 🔗 全部匹配 (allOf)")
        output.append("")
        output.extend(_format_schema_list(schema.all_of, service_model, visited_refs, level=0))
        output.append("")
    
    if schema.any_of:
        output.append("### 🔀 任一匹配 (anyOf)")
        output.append("")
        output.extend(_format_schema_list(schema.any_of, service_model, visited_refs, level=0))
        output.append("")
    
    if schema.one_of:
        output.append("### ⚡ 单一匹配 (oneOf)")
        output.append("")
        output.extend(_format_schema_list(schema.one_of, service_model, visited_refs, level=0))
        output.append("")
    
    output.append("---")
    output.append("💡 **提示**: 使用 ` + "`" + `listSchemas` + "`" + ` 查看所有可用的数据模型")
    
    return "\n".join(output)


def _format_properties(schema: Schema, service_model: ServiceModel, 
                      visited_refs: Set[str], level: int) -> List[str]:
    """格式化属性列表"""
    output = []
    
    if not schema.properties:
        return output
    
    required_fields = set(schema.required or [])
    
    for prop_name in sorted(schema.properties.keys()):
        prop_schema = schema.properties[prop_name]
        required_indicator = " *(必需)*" if prop_name in required_fields else " *(可选)*"
        
        indent = "  " * level
        output.append(f"{indent}- **{prop_name}**{required_indicator}")
        
        # 递归处理属性Schema
        prop_details = _format_schema_or_ref(prop_schema, service_model, visited_refs, level + 1)
        output.extend([f"  {line}" for line in prop_details])
        
        output.append("")
    
    return output


def _format_schema_or_ref(schema_or_ref: SchemaOrRef, service_model: ServiceModel,
                         visited_refs: Set[str], level: int) -> List[str]:
    """格式化SchemaOrRef对象"""
    output = []
    indent = "  " * level
    
    if schema_or_ref.ref:
        # 处理引用
        ref_name = schema_or_ref.ref.ref.replace("#/components/schemas/", "")
        
        if ref_name in visited_refs:
            output.append(f"{indent}📎 引用: ` + "`" + `{ref_name}` + "`" + ` *(循环引用，已访问)*")
            return output
        
        if ref_name in service_model.schemas:
            visited_refs.add(ref_name)
            referenced_schema = service_model.schemas[ref_name]
            
            output.append(f"{indent}📎 引用: ` + "`" + `{ref_name}` + "`" + ` ({referenced_schema.type or 'object'})")
            
            if referenced_schema.description:
                desc = referenced_schema.description
                if len(desc) > 80:
                    desc = desc[:77] + "..."
                output.append(f"{indent}  - {desc}")
            
            # 如果引用的Schema有属性且层级不太深，展示一些基本信息
            if level < 2 and referenced_schema.properties:
                output.append(f"{indent}  - 属性: {len(referenced_schema.properties)} 个")
                if referenced_schema.required:
                    output.append(f"{indent}  - 必需: {len(referenced_schema.required)} 个")
            
            visited_refs.discard(ref_name)
        else:
            output.append(f"{indent}📎 引用: ` + "`" + `{ref_name}` + "`" + ` *(未找到定义)*")
            
    elif schema_or_ref.schema:
        # 处理直接Schema定义
        schema = schema_or_ref.schema
        schema_type = schema.type or "object"
        
        type_info = f"{indent}📄 类型: ` + "`" + `{schema_type}` + "`" + `"
        if schema.format:
            type_info += f" (格式: ` + "`" + `{schema.format}` + "`" + `)"
        output.append(type_info)
        
        if schema.description:
            desc = schema.description
            if len(desc) > 80:
                desc = desc[:77] + "..."
            output.append(f"{indent}  - {desc}")
        
        if schema.example is not None:
            output.append(f"{indent}  - 示例: ` + "`" + `{_format_example(schema.example)}` + "`" + `")
        
        # 递归处理嵌套属性（仅在层级不太深时）
        if level < 3 and schema.properties:
            output.append(f"{indent}  - 属性:")
            nested_props = _format_properties(schema, service_model, visited_refs, level + 1)
            output.extend([f"  {line}" for line in nested_props])
        elif schema.properties:
            output.append(f"{indent}  - 属性: {len(schema.properties)} 个")
        
        # 处理数组项目
        if schema.items:
            output.append(f"{indent}  - 数组项目:")
            item_details = _format_schema_or_ref(schema.items, service_model, visited_refs, level + 1)
            output.extend([f"  {line}" for line in item_details])
        
        # 处理枚举
        if schema.enum:
            enum_values = ", ".join([str(v) for v in schema.enum[:5]])
            if len(schema.enum) > 5:
                enum_values += f" (+{len(schema.enum)-5})"
            output.append(f"{indent}  - 枚举值: {enum_values}")
    
    return output


def _format_schema_list(schema_list: List[SchemaOrRef], service_model: ServiceModel,
                       visited_refs: Set[str], level: int) -> List[str]:
    """格式化Schema列表"""
    output = []
    
    for i, schema_or_ref in enumerate(schema_list):
        output.append(f"{i+1}.")
        schema_details = _format_schema_or_ref(schema_or_ref, service_model, visited_refs, level)
        output.extend([f"   {line}" for line in schema_details])
        output.append("")
    
    return output


def _format_example(example: Any) -> str:
    """格式化示例值"""
    if example is None:
        return "null"
    elif isinstance(example, str):
        return f'"{example}"' if len(str(example)) < 50 else f'"{str(example)[:47]}..."'
    elif isinstance(example, (dict, list)):
        example_str = str(example)
        return example_str if len(example_str) < 100 else f"{example_str[:97]}..."
    else:
        return str(example)


def _get_type_emoji(schema_type: str) -> str:
    """获取Schema类型对应的emoji"""
    emojis = {
        "object": "📦",
        "array": "📋", 
        "string": "📝",
        "number": "🔢",
        "integer": "🔢",
        "boolean": "☑️",
        "null": "⚫"
    }
    return emojis.get(schema_type.lower(), "📄")
`

// TestsInitPyTemplate tests/__init__.py测试包初始化模板
const TestsInitPyTemplate = `"""
测试包初始化文件
为{{.ServiceTitle}} MCP服务器提供测试功能

Generated by swagger2mcp
"""

# 导入常用测试工具和配置
import sys
import os
from pathlib import Path

# 确保能够导入源代码包
src_path = Path(__file__).parent.parent / "src"
if str(src_path) not in sys.path:
    sys.path.insert(0, str(src_path))

# 测试配置
TEST_DATA_DIR = Path(__file__).parent / "data"
TEMP_DIR = Path(__file__).parent / "temp"

# 创建测试所需的目录
TEST_DATA_DIR.mkdir(exist_ok=True)
TEMP_DIR.mkdir(exist_ok=True)

__version__ = "1.0.0"
__author__ = "Generated by swagger2mcp"
`

// TestMCPMethodsPyTemplate tests/test_mcp_methods.py MCP方法单元测试模板
const TestMCPMethodsPyTemplate = `"""
MCP工具方法的单元测试
测试所有MCP方法的基本功能和正确性

Generated by swagger2mcp
"""

import pytest
import json
from typing import Dict, List, Any, Optional
from unittest.mock import Mock, patch

# 导入被测试的模块
from {{.PackageName}}.spec.loader import load_service_model
from {{.PackageName}}.spec.model import ServiceModel
from {{.PackageName}}.mcp.methods import (
    list_endpoints, 
    search_endpoints, 
    get_endpoint_details, 
    list_schemas, 
    get_schema_details
)


class TestMCPMethods:
    """MCP方法测试类"""
    
    @pytest.fixture(scope="class")
    def service_model(self) -> ServiceModel:
        """
        提供测试用的ServiceModel实例
        
        Returns:
            加载的ServiceModel对象
        """
        try:
            model = load_service_model()
            assert model is not None, "ServiceModel不能为空"
            return model
        except Exception as e:
            pytest.fail(f"加载ServiceModel失败: {e}")
    
    @pytest.fixture
    def mock_empty_service_model(self) -> ServiceModel:
        """
        提供空的ServiceModel用于边界测试
        
        Returns:
            空的ServiceModel对象
        """
        from {{.PackageName}}.spec.model import ServiceModel
        return ServiceModel(
            title="Empty Test API",
            version="0.0.1", 
            description="用于测试的空API",
            servers=[],
            tags=[],
            endpoints=[],
            schemas={}
        )
    
    def test_load_service_model_success(self, service_model: ServiceModel):
        """测试ServiceModel加载成功"""
        assert service_model is not None
        assert hasattr(service_model, 'title')
        assert hasattr(service_model, 'version')
        assert hasattr(service_model, 'endpoints')
        assert hasattr(service_model, 'schemas')
        print(f"✅ 成功加载ServiceModel: {service_model.title} v{service_model.version}")
    
    def test_list_endpoints_overview(self, service_model: ServiceModel):
        """测试端点概览功能"""
        overview = list_endpoints.format_endpoints_overview(service_model)
        
        # 基本验证
        assert isinstance(overview, str), "返回结果应该是字符串"
        assert len(overview) > 0, "概览内容不能为空"
        assert "API 接口概览" in overview, "应包含标题"
        
        # 如果有端点，应该包含统计信息
        if service_model.endpoints:
            assert "总计" in overview, "应包含端点总数统计"
            assert "按方法分类" in overview or "按标签分类" in overview, "应包含分类统计"
        
        print(f"✅ 端点概览生成成功，内容长度: {len(overview)}")
    
    def test_list_endpoints_empty_model(self, mock_empty_service_model: ServiceModel):
        """测试空模型的端点概览"""
        overview = list_endpoints.format_endpoints_overview(mock_empty_service_model)
        
        assert isinstance(overview, str)
        assert "暂无可用的API端点" in overview
        print("✅ 空模型端点概览处理正确")
    
    def test_search_endpoints_keyword(self, service_model: ServiceModel):
        """测试关键字搜索功能"""
        if not service_model.endpoints:
            pytest.skip("没有端点数据，跳过搜索测试")
        
        # 测试关键字搜索
        search_params = {
            "keyword": "api", 
            "tag": "", 
            "method": "", 
            "path_pattern": ""
        }
        results = search_endpoints.search_endpoints(service_model, search_params)
        
        assert isinstance(results, list), "搜索结果应该是列表"
        
        # 如果有结果，验证结果结构
        if results:
            result = results[0]
            required_keys = ["id", "method", "path", "summary", "tags"]
            for key in required_keys:
                assert key in result, f"搜索结果应包含字段: {key}"
        
        # 测试搜索结果格式化
        formatted = search_endpoints.format_search_results(results, search_params)
        assert isinstance(formatted, str)
        assert "接口搜索结果" in formatted
        
        print(f"✅ 关键字搜索测试通过，找到 {len(results)} 个结果")
    
    def test_search_endpoints_by_method(self, service_model: ServiceModel):
        """测试按HTTP方法搜索"""
        if not service_model.endpoints:
            pytest.skip("没有端点数据，跳过方法搜索测试")
        
        # 获取第一个端点的方法进行搜索
        first_method = service_model.endpoints[0].method.lower()
        search_params = {
            "keyword": "", 
            "tag": "", 
            "method": first_method, 
            "path_pattern": ""
        }
        
        results = search_endpoints.search_endpoints(service_model, search_params)
        assert isinstance(results, list)
        
        # 验证所有结果都是指定的HTTP方法
        for result in results:
            assert result["method"].lower() == first_method.upper(), "搜索结果方法应匹配"
        
        print(f"✅ HTTP方法搜索测试通过，方法: {first_method.upper()}")
    
    def test_search_endpoints_no_results(self, service_model: ServiceModel):
        """测试搜索无结果的情况"""
        search_params = {
            "keyword": "不存在的关键字xyz123", 
            "tag": "", 
            "method": "", 
            "path_pattern": ""
        }
        
        results = search_endpoints.search_endpoints(service_model, search_params)
        assert isinstance(results, list)
        assert len(results) == 0, "应该没有搜索结果"
        
        formatted = search_endpoints.format_search_results(results, search_params)
        assert "未找到匹配的接口" in formatted
        print("✅ 无结果搜索处理正确")
    
    def test_get_endpoint_details_by_id(self, service_model: ServiceModel):
        """测试通过ID获取端点详情"""
        if not service_model.endpoints:
            pytest.skip("没有端点数据，跳过详情查询测试")
        
        # 使用第一个端点进行测试
        endpoint_id = service_model.endpoints[0].id
        endpoint, found = get_endpoint_details.get_endpoint_details(service_model, endpoint_id)
        
        assert found, f"应该找到端点: {endpoint_id}"
        assert endpoint is not None, "端点对象不应为空"
        assert endpoint.id == endpoint_id, "返回的端点ID应该匹配"
        
        # 测试格式化详情
        formatted = get_endpoint_details.format_endpoint_details(endpoint, service_model)
        assert isinstance(formatted, str)
        assert len(formatted) > 0
        assert endpoint.method.upper() in formatted
        assert endpoint.path in formatted
        
        print(f"✅ 端点详情查询测试通过，ID: {endpoint_id}")
    
    def test_get_endpoint_details_by_method_path(self, service_model: ServiceModel):
        """测试通过方法和路径获取端点详情"""
        if not service_model.endpoints:
            pytest.skip("没有端点数据，跳过详情查询测试")
        
        # 使用第一个端点进行测试
        first_endpoint = service_model.endpoints[0]
        method = first_endpoint.method
        path = first_endpoint.path
        
        endpoint, found = get_endpoint_details.get_endpoint_details(service_model, method, path)
        
        assert found, f"应该找到端点: {method} {path}"
        assert endpoint is not None, "端点对象不应为空"
        assert endpoint.method == method, "返回的端点方法应该匹配"
        assert endpoint.path == path, "返回的端点路径应该匹配"
        
        print(f"✅ 方法路径查询测试通过，{method} {path}")
    
    def test_get_endpoint_details_not_found(self, service_model: ServiceModel):
        """测试查询不存在的端点"""
        # 测试不存在的端点ID
        endpoint, found = get_endpoint_details.get_endpoint_details(service_model, "不存在的ID")
        assert not found, "应该找不到不存在的端点"
        assert endpoint is None, "不存在的端点应返回None"
        
        # 测试不存在的方法和路径
        endpoint, found = get_endpoint_details.get_endpoint_details(service_model, "INVALID", "/nonexistent")
        assert not found, "应该找不到不存在的端点"
        assert endpoint is None, "不存在的端点应返回None"
        
        print("✅ 端点不存在情况处理正确")
    
    def test_list_schemas_overview(self, service_model: ServiceModel):
        """测试Schema列表功能"""
        schemas = list_schemas.list_schemas(service_model)
        assert isinstance(schemas, list), "Schema列表应该是list"
        
        # 如果有Schema，验证数据结构
        if schemas:
            schema_info = schemas[0]
            required_keys = ["name", "type", "description", "has_properties", "property_count"]
            for key in required_keys:
                assert key in schema_info, f"Schema信息应包含字段: {key}"
        
        # 测试格式化显示
        formatted = list_schemas.format_schemas_list(schemas)
        assert isinstance(formatted, str)
        assert "数据模型" in formatted
        
        print(f"✅ Schema列表测试通过，共 {len(schemas)} 个Schema")
    
    def test_list_schemas_empty_model(self, mock_empty_service_model: ServiceModel):
        """测试空模型的Schema列表"""
        schemas = list_schemas.list_schemas(mock_empty_service_model)
        assert isinstance(schemas, list)
        assert len(schemas) == 0, "空模型应该没有Schema"
        
        formatted = list_schemas.format_schemas_list(schemas)
        assert "暂无可用的数据模型定义" in formatted
        print("✅ 空Schema列表处理正确")
    
    def test_get_schema_details_success(self, service_model: ServiceModel):
        """测试Schema详情查询成功情况"""
        if not service_model.schemas:
            pytest.skip("没有Schema数据，跳过详情查询测试")
        
        # 使用第一个Schema进行测试
        schema_name = list(service_model.schemas.keys())[0]
        schema, found = get_schema_details.get_schema_details(service_model, schema_name)
        
        assert found, f"应该找到Schema: {schema_name}"
        assert schema is not None, "Schema对象不应为空"
        assert schema.name == schema_name, "返回的Schema名称应该匹配"
        
        # 测试格式化详情
        formatted = get_schema_details.format_schema_details(schema, service_model)
        assert isinstance(formatted, str)
        assert len(formatted) > 0
        assert schema_name in formatted
        
        print(f"✅ Schema详情查询测试通过，名称: {schema_name}")
    
    def test_get_schema_details_not_found(self, service_model: ServiceModel):
        """测试查询不存在的Schema"""
        schema, found = get_schema_details.get_schema_details(service_model, "不存在的Schema")
        assert not found, "应该找不到不存在的Schema"
        assert schema is None, "不存在的Schema应返回None"
        print("✅ Schema不存在情况处理正确")
    
    def test_all_methods_with_empty_model(self, mock_empty_service_model: ServiceModel):
        """测试所有方法对空模型的处理"""
        # 测试所有主要方法都能正确处理空模型
        
        # list_endpoints
        overview = list_endpoints.format_endpoints_overview(mock_empty_service_model)
        assert "暂无可用的API端点" in overview
        
        # search_endpoints
        results = search_endpoints.search_endpoints(mock_empty_service_model, {"keyword": "test"})
        assert len(results) == 0
        
        # get_endpoint_details
        endpoint, found = get_endpoint_details.get_endpoint_details(mock_empty_service_model, "test")
        assert not found
        
        # list_schemas
        schemas = list_schemas.list_schemas(mock_empty_service_model)
        assert len(schemas) == 0
        
        # get_schema_details
        schema, found = get_schema_details.get_schema_details(mock_empty_service_model, "test")
        assert not found
        
        print("✅ 所有方法的空模型处理测试通过")
    
    @pytest.mark.parametrize("method_name,args", [
        ("list_endpoints", []),
        ("search_endpoints", [{"keyword": "test"}]),
        ("get_endpoint_details", ["test_id"]),
        ("list_schemas", []),
        ("get_schema_details", ["test_schema"]),
    ])
    def test_method_error_handling(self, method_name: str, args: List[Any], service_model: ServiceModel):
        """测试方法的错误处理"""
        # 这个测试确保所有方法都能处理各种输入而不崩溃
        try:
            if method_name == "list_endpoints":
                list_endpoints.format_endpoints_overview(service_model)
            elif method_name == "search_endpoints":
                search_endpoints.search_endpoints(service_model, args[0])
            elif method_name == "get_endpoint_details":
                get_endpoint_details.get_endpoint_details(service_model, args[0])
            elif method_name == "list_schemas":
                list_schemas.list_schemas(service_model)
            elif method_name == "get_schema_details":
                get_schema_details.get_schema_details(service_model, args[0])
        except Exception as e:
            pytest.fail(f"方法 {method_name} 应该能处理输入而不抛出异常: {e}")
        
        print(f"✅ 方法 {method_name} 错误处理测试通过")
    
    def test_search_performance(self, service_model: ServiceModel):
        """测试搜索性能"""
        if not service_model.endpoints:
            pytest.skip("没有端点数据，跳过性能测试")
        
        import time
        
        # 测试搜索性能 - 应该能在合理时间内完成
        start_time = time.time()
        
        for _ in range(10):  # 执行10次搜索
            search_endpoints.search_endpoints(service_model, {"keyword": "api"})
        
        end_time = time.time()
        avg_time = (end_time - start_time) / 10
        
        # 平均搜索时间应该小于100ms（相对宽松的限制）
        assert avg_time < 0.1, f"搜索性能过慢: {avg_time:.4f}s per search"
        print(f"✅ 搜索性能测试通过，平均耗时: {avg_time:.4f}s")
    
    def test_output_format_consistency(self, service_model: ServiceModel):
        """测试输出格式的一致性"""
        # 确保所有方法的输出都是字符串且包含预期的格式标记
        
        if service_model.endpoints:
            # 端点概览格式
            overview = list_endpoints.format_endpoints_overview(service_model)
            assert "##" in overview, "应包含Markdown标题格式"
            assert "**" in overview, "应包含Markdown粗体格式"
            
            # 搜索结果格式
            results = search_endpoints.search_endpoints(service_model, {"keyword": ""})
            formatted = search_endpoints.format_search_results(results, {"keyword": ""})
            assert "##" in formatted, "搜索结果应包含标题"
            
            # 端点详情格式
            endpoint, found = get_endpoint_details.get_endpoint_details(service_model, service_model.endpoints[0].id)
            if found:
                formatted = get_endpoint_details.format_endpoint_details(endpoint, service_model)
                assert "##" in formatted, "端点详情应包含标题"
        
        if service_model.schemas:
            # Schema列表格式
            schemas = list_schemas.list_schemas(service_model)
            formatted = list_schemas.format_schemas_list(schemas)
            assert "##" in formatted, "Schema列表应包含标题"
            
            # Schema详情格式
            schema_name = list(service_model.schemas.keys())[0]
            schema, found = get_schema_details.get_schema_details(service_model, schema_name)
            if found:
                formatted = get_schema_details.format_schema_details(schema, service_model)
                assert "##" in formatted, "Schema详情应包含标题"
        
        print("✅ 输出格式一致性测试通过")


# 测试运行配置
if __name__ == "__main__":
    # 可以直接运行此文件进行测试
    pytest.main([__file__, "-v", "--tb=short"])
`

// ReadmeMdTemplate README.md项目文档模板
const ReadmeMdTemplate = `# {{.ServiceTitle}} MCP 工具

{{.ServiceTitle}}的MCP（Model Context Protocol）服务器，通过标准输入输出提供API文档查询功能。

> 🤖 此项目由 swagger2mcp 工具自动生成

## 功能特性

- **API文档查询**: 查看所有可用的API端点
- **智能搜索**: 支持关键字、标签、HTTP方法、路径模式搜索
- **详细信息**: 获取端点参数、请求体、响应的详细信息
- **数据模型**: 浏览和查看Schema定义
- **MCP协议**: 遵循MCP协议标准，与各种AI客户端兼容

## 快速开始

### 系统要求

- Python 3.8 或更高版本
- pip 包管理器

### 安装

1. 安装依赖:
   pip install -r requirements.txt

2. 开发安装（可选）:
   pip install -e .

### 使用方法

作为MCP服务器运行:
python -m {{.PackageName}}.main

## 可用工具

- **listEndpoints**: 列出所有可用的API端点
- **searchEndpoints**: 根据条件搜索API端点
- **getEndpointDetails**: 获取指定API端点的详细信息
- **listSchemas**: 列出所有可用的数据模型定义
- **getSchemaDetails**: 获取指定数据模型的详细信息

## API信息

- **服务名称**: {{.ServiceTitle}}
- **版本**: {{.Version}}

---

> 注意: 这是一个自动生成的项目。如需更新，请修改原始API规范并重新生成。
`

// SetupPyTemplate setup.py项目安装配置模板
const SetupPyTemplate = `"""
{{.ServiceTitle}} MCP 工具安装配置
通过标准输入输出提供 MCP (Model Context Protocol) 服务

Generated by swagger2mcp
"""

from setuptools import setup, find_packages
from pathlib import Path

# 读取README文件作为长描述
this_directory = Path(__file__).parent
long_description = (this_directory / "README.md").read_text(encoding='utf-8')

setup(
    name="{{.PackageName}}",
    version="{{.Version}}",
    author="{{.Author}}",
    author_email="noreply@example.com",
    description="{{.ServiceTitle}}的MCP服务器 - 提供API文档查询功能",
    long_description=long_description,
    long_description_content_type="text/markdown",
    url="https://github.com/mark3labs/swagger2mcp",
    packages=find_packages(where="src"),
    package_dir={"": "src"},
    package_data={
        "{{.PackageName}}.spec": ["model.json"],
    },
    include_package_data=True,
    classifiers=[
        "Development Status :: 4 - Beta",
        "Intended Audience :: Developers",
        "Topic :: Software Development :: Documentation",
        "Topic :: Internet :: WWW/HTTP :: Dynamic Content",
        "License :: OSI Approved :: MIT License",
        "Programming Language :: Python :: 3",
        "Programming Language :: Python :: 3.8",
        "Programming Language :: Python :: 3.9",
        "Programming Language :: Python :: 3.10",
        "Programming Language :: Python :: 3.11",
        "Programming Language :: Python :: 3.12",
        "Operating System :: OS Independent",
    ],
    python_requires=">=3.8",
    install_requires=[
        "dataclasses-json>=0.6.0",
        "typing-extensions>=4.5.0",
    ],
    extras_require={
        "dev": [
            "black>=23.0.0",
            "mypy>=1.5.0", 
            "pytest>=7.4.0",
            "pytest-cov>=4.1.0",
            "flake8>=6.0.0",
            "isort>=5.12.0",
        ]
    },
    entry_points={
        "console_scripts": [
            "{{.ToolName}}={{.PackageName}}.main:main",
        ],
    },
    keywords="mcp api documentation openapi swagger",
    project_urls={
        "Documentation": "https://github.com/mark3labs/swagger2mcp",
        "Source": "https://github.com/mark3labs/swagger2mcp",
        "Tracker": "https://github.com/mark3labs/swagger2mcp/issues",
    },
)`

// RequirementsTxtTemplate requirements.txt运行时依赖模板
const RequirementsTxtTemplate = `# {{.ServiceTitle}} MCP 工具运行时依赖
# Generated by swagger2mcp

# MCP协议相关依赖
dataclasses-json>=0.6.0
typing-extensions>=4.5.0

# JSON处理和数据验证
# 注意：Python 3.8+ 内置了json模块，无需额外依赖
`

// RequirementsDevTxtTemplate requirements-dev.txt开发依赖模板
const RequirementsDevTxtTemplate = `# {{.ServiceTitle}} MCP 工具开发依赖
# Generated by swagger2mcp

# 包含运行时依赖
-r requirements.txt

# 代码格式化
black>=23.0.0
isort>=5.12.0

# 类型检查
mypy>=1.5.0
types-setuptools>=68.0.0

# 测试框架
pytest>=7.4.0
pytest-cov>=4.1.0
pytest-asyncio>=0.21.0

# 代码质量检查
flake8>=6.0.0
pylint>=2.17.0
bandit>=1.7.5  # 安全漏洞检查
safety>=2.3.0  # 依赖安全检查

# 代码复杂度检查
radon>=6.0.1
xenon>=0.9.0

# 文档字符串检查
pydocstyle>=6.3.0

# 导入排序检查
isort[colors]>=5.12.0

# 预提交钩子
pre-commit>=3.3.0

# Python 3.8+ 兼容性检查
pyupgrade>=3.10.0
vermin>=1.5.2

# 构建工具
build>=0.10.0
twine>=4.0.0
`

// PyprojectTomlTemplate pyproject.toml现代Python项目配置模板
const PyprojectTomlTemplate = `# {{.ServiceTitle}} MCP 工具项目配置
# Generated by swagger2mcp

[build-system]
requires = ["setuptools>=61.0", "wheel"]
build-backend = "setuptools.build_meta"

[project]
name = "{{.PackageName}}"
version = "{{.Version}}"
description = "{{.ServiceTitle}}的MCP服务器 - 提供API文档查询功能"
authors = [
    {name = "{{.Author}}"},
]
readme = "README.md"
requires-python = ">=3.8"
classifiers = [
    "Development Status :: 4 - Beta",
    "Intended Audience :: Developers",
    "Topic :: Software Development :: Documentation",
    "Topic :: Internet :: WWW/HTTP :: Dynamic Content",
    "License :: OSI Approved :: MIT License",
    "Programming Language :: Python :: 3",
    "Programming Language :: Python :: 3.8",
    "Programming Language :: Python :: 3.9",
    "Programming Language :: Python :: 3.10",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: Python :: 3.12",
    "Operating System :: OS Independent",
]
dependencies = [
    "dataclasses-json>=0.6.0",
    "typing-extensions>=4.5.0",
]
keywords = ["mcp", "api", "documentation", "openapi", "swagger"]

[project.urls]
Documentation = "https://github.com/mark3labs/swagger2mcp"
Source = "https://github.com/mark3labs/swagger2mcp"
Tracker = "https://github.com/mark3labs/swagger2mcp/issues"

[project.scripts]
"{{.ToolName}}" = "{{.PackageName}}.main:main"

[project.optional-dependencies]
dev = [
    "black>=23.0.0",
    "isort>=5.12.0", 
    "mypy>=1.5.0",
    "pytest>=7.4.0",
    "pytest-cov>=4.1.0",
    "flake8>=6.0.0",
    "pylint>=2.17.0",
]

# 工具配置
[tool.black]
line-length = 88
target-version = ['py38']
include = '\.pyi?$'
extend-exclude = '''
# A regex preceded by ^/ will apply only to files and directories
# in the root of the project.
^/docs/  # exclude docs directory
'''

[tool.isort]
profile = "black"
line_length = 88
multi_line_output = 3
include_trailing_comma = true
force_grid_wrap = 0
use_parentheses = true
ensure_newline_before_comments = true

[tool.mypy]
python_version = "3.8"
strict = true
warn_return_any = true
warn_unused_configs = true
disallow_untyped_defs = true
disallow_incomplete_defs = true
check_untyped_defs = true
disallow_untyped_decorators = true
no_implicit_optional = true
warn_redundant_casts = true
warn_unused_ignores = true
warn_no_return = true
warn_unreachable = true
strict_equality = true

[[tool.mypy.overrides]]
module = ["tests.*"]
disallow_untyped_defs = false

[tool.pytest.ini_options]
testpaths = ["tests"]
python_files = ["test_*.py", "*_test.py"]
python_classes = ["Test*"]
python_functions = ["test_*"]
addopts = [
    "--strict-markers",
    "--strict-config",
    "--cov={{.PackageName}}",
    "--cov-report=term-missing",
    "--cov-report=html",
    "--cov-report=xml",
]
markers = [
    "slow: marks tests as slow (deselect with '-m \"not slow\"')",
    "integration: marks tests as integration tests",
]

[tool.coverage.run]
source = ["src"]
branch = true

[tool.coverage.report]
exclude_lines = [
    "pragma: no cover",
    "def __repr__",
    "if self.debug:",
    "if settings.DEBUG",
    "raise AssertionError",
    "raise NotImplementedError",
    "if 0:",
    "if __name__ == .__main__.:",
    "class .*\\bProtocol\\):",
    "@(abc\\.)?abstractmethod",
]

[tool.flake8]
max-line-length = 88
select = ["E", "F", "W", "C90"]
ignore = [
    "E203",  # whitespace before ':'
    "E501",  # line too long (handled by black)
    "W503",  # line break before binary operator
]
exclude = [
    ".git",
    "__pycache__",
    "build",
    "dist",
    ".eggs",
    "*.egg-info",
    ".venv",
    "venv",
]

[tool.bandit]
targets = ["src/{{.PackageName}}"]
exclude_dirs = ["tests"]
skips = ["B101", "B601"]

[tool.pydocstyle]
convention = "google"
add_ignore = "D100,D104"

[tool.pyupgrade]
py38-plus = true

[tool.vermin]
targets = ["3.8-"]
backport = ["typing"]
no-tips = true
`

// MakefileTemplate Makefile开发任务管理模板
const MakefileTemplate = `# {{.ServiceTitle}} MCP 工具开发任务
# Generated by swagger2mcp

.PHONY: help install install-dev test format lint clean build upload check security quality compat upgrade

# 默认目标：显示帮助信息
help:
	@echo "{{.ServiceTitle}} MCP 工具开发命令:"
	@echo ""
	@echo "  install     安装项目依赖"
	@echo "  install-dev 安装开发依赖" 
	@echo "  test        运行测试"
	@echo "  format      格式化代码"
	@echo "  lint        检查代码质量"
	@echo "  security    安全漏洞检查"
	@echo "  quality     全面代码质量检查"
	@echo "  compat      Python 3.8+ 兼容性检查"
	@echo "  upgrade     升级代码到现代Python语法"
	@echo "  clean       清理构建文件"
	@echo "  build       构建项目"
	@echo "  upload      上传到PyPI"
	@echo "  check       运行所有检查"
	@echo ""

# 安装项目依赖
install:
	pip install -e .

# 安装开发依赖
install-dev:
	pip install -e ".[dev]"
	pip install -r requirements-dev.txt

# 运行测试
test:
	pytest tests/ -v --cov={{.PackageName}} --cov-report=term-missing --cov-report=html

# 格式化代码
format:
	pyupgrade --py38-plus src/**/*.py tests/**/*.py
	black src/ tests/
	isort src/ tests/

# 检查代码质量 (基础检查)
lint:
	flake8 src/ tests/
	mypy src/
	black --check src/ tests/
	isort --check-only src/ tests/

# 安全漏洞检查
security:
	bandit -r src/ -f json -o bandit-report.json || bandit -r src/
	safety check --json --output safety-report.json || safety check

# 全面代码质量检查
quality: lint security
	pylint src/{{.PackageName}}/ --output-format=json --output=pylint-report.json || pylint src/{{.PackageName}}/
	pydocstyle src/{{.PackageName}}/ || echo "文档字符串检查完成"
	radon cc src/{{.PackageName}}/ -a -nb
	radon mi src/{{.PackageName}}/ -nb
	xenon --max-absolute A --max-modules A --max-average A src/{{.PackageName}}/

# Python 3.8+ 兼容性检查
compat:
	vermin -t=3.8- src/{{.PackageName}}/
	vermin -t=3.8- tests/

# 升级代码到现代Python语法
upgrade:
	pyupgrade --py38-plus src/**/*.py tests/**/*.py

# 清理构建文件和报告
clean:
	rm -rf build/
	rm -rf dist/
	rm -rf *.egg-info/
	find . -type d -name __pycache__ -delete
	find . -type f -name "*.pyc" -delete
	find . -type f -name "*.pyo" -delete
	find . -type f -name "*~" -delete
	find . -type f -name ".*~" -delete
	rm -rf .coverage
	rm -rf htmlcov/
	rm -rf .pytest_cache/
	rm -rf .mypy_cache/
	rm -f bandit-report.json safety-report.json pylint-report.json

# 构建项目
build: clean
	python -m build

# 上传到PyPI (需要先配置API token)
upload: build
	python -m twine upload dist/*

# 运行所有检查
check: quality compat test
	@echo "所有检查完成!"

# 快速检查（用于CI/CD）
ci-check:
	pytest tests/ --tb=short -q
	flake8 src/
	mypy src/
	black --check src/ tests/
	bandit -r src/ -q
	vermin -t=3.8- src/{{.PackageName}}/ -q

# 预提交检查
pre-commit: format quality
	@echo "预提交检查通过!"
`

// GitignoreTemplate .gitignore文件模板
const GitignoreTemplate = `# {{.ServiceTitle}} MCP 工具 .gitignore
# Generated by swagger2mcp

# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/

# Translations
*.mo
*.pot

# Django stuff:
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
.pybuilder/
target/

# Jupyter Notebook
.ipynb_checkpoints

# IPython
profile_default/
ipython_config.py

# pyenv
.python-version

# pipenv
Pipfile.lock

# poetry
poetry.lock

# pdm
.pdm.toml

# PEP 582
__pypackages__/

# Celery stuff
celerybeat-schedule
celerybeat.pid

# SageMath parsed files
*.sage.py

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Pyre type checker
.pyre/

# pytype static type analyzer
.pytype/

# Cython debug symbols
cython_debug/

# PyCharm
.idea/

# VSCode
.vscode/

# macOS
.DS_Store

# Windows
Thumbs.db
ehthumbs.db
Desktop.ini
`

// EditorconfigTemplate .editorconfig编辑器配置模板
const EditorconfigTemplate = `# {{.ServiceTitle}} MCP 工具编辑器配置
# Generated by swagger2mcp

root = true

[*]
charset = utf-8
end_of_line = lf
insert_final_newline = true
trim_trailing_whitespace = true
indent_style = space
indent_size = 4

[*.{py,pyi}]
indent_size = 4
max_line_length = 88

[*.{json,yaml,yml}]
indent_size = 2

[*.md]
trim_trailing_whitespace = false

[Makefile]
indent_style = tab
`

// PreCommitConfigTemplate pre-commit配置模板
const PreCommitConfigTemplate = `# {{.ServiceTitle}} MCP 工具预提交钩子配置
# Generated by swagger2mcp

repos:
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.4.0
    hooks:
      - id: trailing-whitespace
      - id: end-of-file-fixer
      - id: check-yaml
      - id: check-json
      - id: check-merge-conflict
      - id: debug-statements
      - id: check-docstring-first

  - repo: https://github.com/asottile/pyupgrade
    rev: v3.10.1
    hooks:
      - id: pyupgrade
        args: [--py38-plus]

  - repo: https://github.com/psf/black
    rev: 23.9.1
    hooks:
      - id: black
        language_version: python3

  - repo: https://github.com/pycqa/isort
    rev: 5.12.0
    hooks:
      - id: isort
        args: ["--profile", "black"]

  - repo: https://github.com/pycqa/flake8
    rev: 6.1.0
    hooks:
      - id: flake8
        additional_dependencies: [flake8-docstrings]

  - repo: https://github.com/pre-commit/mirrors-mypy
    rev: v1.5.1
    hooks:
      - id: mypy
        additional_dependencies: [types-setuptools]

  - repo: https://github.com/PyCQA/bandit
    rev: 1.7.5
    hooks:
      - id: bandit
        args: ["-c", "pyproject.toml"]

  - repo: https://github.com/pycqa/pydocstyle
    rev: 6.3.0
    hooks:
      - id: pydocstyle
        args: [--convention=google]

  - repo: https://github.com/netromdk/vermin
    rev: v1.5.2
    hooks:
      - id: vermin
        args: ["-t=3.8-", "--no-tips"]
`

// MyPyConfigTemplate mypy.ini配置模板
const MyPyConfigTemplate = `# {{.ServiceTitle}} MCP 工具 MyPy 配置
# Generated by swagger2mcp

[mypy]
python_version = 3.8
warn_return_any = True
warn_unused_configs = True
disallow_untyped_defs = True
disallow_incomplete_defs = True
check_untyped_defs = True
disallow_untyped_decorators = True
no_implicit_optional = True
warn_redundant_casts = True
warn_unused_ignores = True
warn_no_return = True
warn_unreachable = True
strict_equality = True
show_error_codes = True

# 第三方库配置
[mypy-pytest.*]
ignore_missing_imports = True

[mypy-setuptools.*]
ignore_missing_imports = True
`

// PylintRcTemplate .pylintrc配置模板
const PylintRcTemplate = `# {{.ServiceTitle}} MCP 工具 Pylint 配置  
# Generated by swagger2mcp

[MASTER]
extension-pkg-whitelist=
jobs=1
limit-inference-results=100
persistent=yes
suggestion-mode=yes
unsafe-load-any-extension=no

[MESSAGES CONTROL]
confidence=
disable=raw-checker-failed,
        bad-inline-option,
        locally-disabled,
        file-ignored,
        suppressed-message,
        useless-suppression,
        deprecated-pragma,
        use-symbolic-message-instead,
        missing-module-docstring,
        too-few-public-methods

[REPORTS]
evaluation=10.0 - ((float(5 * error + warning + refactor + convention) / statement) * 10)
output-format=text
reports=no
score=yes

[REFACTORING]
max-nested-blocks=5
never-returning-functions=sys.exit

[SIMILARITIES]
ignore-comments=yes
ignore-docstrings=yes
ignore-imports=no
min-similarity-lines=4

[SPELLING]
spelling-dict=
spelling-ignore-words=
spelling-private-dict-file=

[TYPECHECK]
contextmanager-decorators=contextlib.contextmanager
generated-members=
ignore-mixin-members=yes
ignore-none=yes
ignore-on-opaque-inference=yes
ignored-classes=optparse.Values,thread._local,_thread._local
ignored-modules=
missing-member-hint=yes
missing-member-hint-distance=1
missing-member-max-choices=1

[VARIABLES]
additional-builtins=
allow-global-unused-variables=yes
callbacks=cb_,_cb
dummy-variables-rgx=_+$|(_[a-zA-Z0-9_]*[a-zA-Z0-9]+?$)|dummy|^ignored_|^unused_
ignored-argument-names=_.*|^ignored_|^unused_
init-import=no
redefining-builtins-modules=six.moves,past.builtins,future.builtins,builtins,io

[FORMAT]
expected-line-ending-format=
ignore-long-lines=^\s*(# )?<?https?://\S+>?$
indent-after-paren=4
indent-string='    '
max-line-length=88
max-module-lines=1000
no-space-check=trailing-comma,dict-separator
single-line-class-stmt=no
single-line-if-stmt=no

[LOGGING]
logging-format-style=old
logging-modules=logging

[MISCELLANEOUS]
notes=FIXME,XXX,TODO

[BASIC]
argument-naming-style=snake_case
attr-naming-style=snake_case
bad-names=foo,bar,baz,toto,tutu,tata
class-attribute-naming-style=any
class-naming-style=PascalCase
const-naming-style=UPPER_CASE
docstring-min-length=-1
function-naming-style=snake_case
good-names=i,j,k,ex,Run,_
include-naming-hint=no
inlinevar-naming-style=any
method-naming-style=snake_case
module-naming-style=snake_case
name-group=
no-docstring-rgx=^_
property-classes=abc.abstractproperty
variable-naming-style=snake_case

[STRING]
check-str-concat-over-line-jumps=no

[IMPORTS]
allow-wildcard-with-all=no
analyse-fallback-blocks=no
deprecated-modules=optparse,tkinter.tix

[CLASSES]
defining-attr-methods=__init__,__new__,setUp,__post_init__
exclude-protected=_asdict,_fields,_replace,_source,_make
valid-classmethod-first-arg=cls
valid-metaclass-classmethod-first-arg=cls

[DESIGN]
max-args=5
max-attributes=7
max-bool-expr=5
max-branches=12
max-locals=15
max-parents=7
max-public-methods=20
max-returns=6
max-statements=50
min-public-methods=2

[EXCEPTIONS]
overgeneral-exceptions=BaseException,Exception
`
