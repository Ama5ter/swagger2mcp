package npmemitter

import (
	"encoding/json"
	"fmt"
	"strings"

	genspec "github.com/mark3labs/swagger2mcp/internal/spec"
)

type templateData struct {
	ToolName     string
	PackageName  string
	serviceTitle string
	service      *genspec.ServiceModel
}

func newTemplateData(toolName, packageName string, sm *genspec.ServiceModel) templateData {
	title := ""
	if sm != nil {
		title = strings.TrimSpace(sm.Title)
	}
	return templateData{
		ToolName:     strings.TrimSpace(toolName),
		PackageName:  strings.TrimSpace(packageName),
		serviceTitle: title,
		service:      sm,
	}
}

func (d templateData) render(content string) string {
	return normalize(content)
}

func (d templateData) title() string {
	return d.serviceTitle
}

func normalize(content string) string {
	trimmed := strings.TrimSpace(content)
	if trimmed == "" {
		return ""
	}
	return trimmed + "\n"
}

// Content renderers

func renderPackageJSON(data templateData) string {
	// Keep minimal but useful scripts and dev deps
	pkg := map[string]any{
		"name":    data.PackageName,
		"version": "0.1.0",
		"private": true,
		"type":    "module",
		"scripts": map[string]string{
			"build":  "tsc -p . && cp src/spec/model.json dist/spec/",
			"start":  "npm run build && node dist/index.js",
			"bundle": "npm run build && mcpb pack . dist/$npm_package_name-$npm_package_version.mcpb",
			"test":   "vitest run",
			"format": "prettier -w .",
			"lint":   "eslint . --ext .ts --max-warnings=0",
		},
		"devDependencies": map[string]string{
			"@typescript-eslint/eslint-plugin": "^7.0.0",
			"@typescript-eslint/parser":        "^7.0.0",
			"eslint":                           "^8.57.0",
			"eslint-config-prettier":           "^9.1.0",
			"@types/node":                      "^20.11.0",
			"prettier":                         "^3.2.5",
			"typescript":                       "^5.4.0",
			"vitest":                           "^1.5.0",
		},
	}
	b, _ := json.MarshalIndent(pkg, "", "  ")
	return string(b) + "\n"
}

func renderTSConfig() string {
	cfg := map[string]any{
		"compilerOptions": map[string]any{
			"target":            "ES2019",
			"module":            "ESNext",
			"moduleResolution":  "Node",
			"strict":            true,
			"declaration":       true,
			"esModuleInterop":   true,
			"resolveJsonModule": true,
			"skipLibCheck":      true,
			"outDir":            "dist",
			"rootDir":           "src",
			"types":             []string{"node"},
		},
		// Build should only include source files; tests are run by vitest
		// and should not be compiled by tsc build.
		"include": []string{"src"},
	}
	b, _ := json.MarshalIndent(cfg, "", "  ")
	return string(b) + "\n"
}

func renderReadme(data templateData) string {
	title := data.title()
	lines := []string{
		fmt.Sprintf("# %s", data.ToolName),
		"",
		fmt.Sprintf("Generated MCP tool for %s (Node + MCPB)", title),
		"",
		"This project was generated by swagger2mcp and exposes MCP methods to query your API documentation.",
		"",
		"- Methods: listEndpoints, searchEndpoints, getEndpointDetails, listSchemas, getSchemaDetails",
		"- Runtime: Node.js (TypeScript, ESM)",
		"- Packaging: MCP Bundles (.mcpb)",
		"",
		"## Quick Start",
		"",
		"```sh",
		"npm install",
		"npm start   # build + run stdio server",
		"```",
		"",
		"The server reads JSON-RPC (newline-delimited) from stdin and writes responses to stdout.",
		"Logs and diagnostics go to stderr.",
		"",
		"## Build",
		"",
		"```sh",
		"npm run build",
		"```",
		"",
		"## Bundle (MCPB)",
		"",
		"Requires the MCPB CLI:",
		"",
		"```sh",
		"npm i -g @anthropic-ai/mcpb",
		"```",
		"",
		"Then:",
		"",
		"```sh",
		"npm run bundle   # outputs dist/<name>-<version>.mcpb",
		"```",
		"",
		"The manifest.json declares:",
		"- server.entry_point: server/index.js",
		"- mcp_config: \"/usr/bin/env\" with args [\"node\", \"${__dirname}/server/index.js\"]",
		"",
		"## Manual Bundle (if needed)",
		"",
		"```sh",
		"npm run build",
		"mkdir -p server && cp -a dist/* server/",
		fmt.Sprintf("zip -r dist/%s.mcpb manifest.json server", data.ToolName),
		"```",
		"",
		"## Claude Import",
		"",
		fmt.Sprintf("- Import dist/%s.mcpb into Claude Desktop", data.ToolName),
		"- The app launches the server via stdio and negotiates MCP",
		"",
		"## Troubleshooting",
		"",
		"- If the server exits right after initialize: ensure the bundle contains package.json at the root (mcpb pack does).",
		"- If Node path issues occur in GUI environments: replace \"/usr/bin/env\"/\"node\" with your absolute Node path in manifest.json and re-bundle.",
		"- notifications/initialized are ignored (no response). logging/setLevel returns success.",
		"- prompts/list, resources/list, resources/templates/list return empty arrays by default.",
	}
	return normalize(strings.Join(lines, "\n"))
}

func renderIndexTs() string {
	// Minimal JSON-RPC (newline-delimited) stdio MCP server for Node.
	return normalize(`import { loadServiceModel } from './spec/loader.js'
import * as Methods from './mcp/methods/index.js'

type JSONRPCId = string | number | null
interface JSONRPCRequest { jsonrpc: '2.0'; id?: JSONRPCId; method: string; params?: any }
interface JSONRPCResponse { jsonrpc: '2.0'; id: JSONRPCId; result?: any; error?: { code: number; message: string; data?: any } }

let sm: any
let serverName: string
let serverVersion: string

try {
  sm = loadServiceModel()
  serverName = (sm.Title && sm.Title.trim()) || 'mcp-tool'
  serverVersion = (sm.Version && sm.Version.trim()) || '0.1.0'
} catch (error) {
  console.error('[mcp-server] failed to load service model:', error)
  process.exit(1)
}

// Minimal tool definitions (JSON Schema is simplified)
const tools = [
  { name: 'listEndpoints', description: 'Show API overview and routing summary', inputSchema: { type: 'object', properties: {} } },
  { name: 'searchEndpoints', description: 'Search endpoints', inputSchema: { type: 'object', properties: { keyword: { type: 'string' }, tag: { type: 'string' }, method: { type: 'string' }, pathPattern: { type: 'string' } } } },
  { name: 'getEndpointDetails', description: 'Get endpoint details by id or method+path', inputSchema: { type: 'object', properties: { id: { type: 'string' }, method: { type: 'string' }, path: { type: 'string' } } } },
  { name: 'listSchemas', description: 'List schemas', inputSchema: { type: 'object', properties: {} } },
  { name: 'getSchemaDetails', description: 'Get schema by name', inputSchema: { type: 'object', properties: { name: { type: 'string' } }, required: ['name'] } },
]

function writeResponse(resp: JSONRPCResponse) {
  // Only ever write JSON-RPC to stdout
  process.stdout.write(JSON.stringify(resp) + '\n')
}

// Helper function to resolve schema references and format schema content
function formatSchemaWithRefs(schema: any, sm: any, indent: string = ''): string[] {
  const lines: string[] = []
  
  if (!schema) return lines
  
  if (schema.Type) {
    lines.push(`+"`"+`${indent}类型: ${schema.Type}`+"`"+`)
  }
  
  if (schema.Properties && Object.keys(schema.Properties).length > 0) {
    lines.push(`+"`"+`${indent}属性:`+"`"+`)
    Object.entries(schema.Properties).forEach(([propName, propSchema]: [string, any]) => {
      const isRequired = schema.Required?.includes(propName) ? '[必需]' : '[可选]'
      
      if (propSchema.Schema) {
        // Direct schema
        const propType = propSchema.Schema.Type || 'unknown'
        if (propType === 'array') {
          // Handle array property with items
          if (propSchema.Schema.Items?.Ref?.Ref) {
            const refName = propSchema.Schema.Items.Ref.Ref.replace('#/components/schemas/', '')
            lines.push(`+"`"+`${indent}  • ${propName}: ${propType}<${refName}> ${isRequired}`+"`"+`)
            
            // Try to resolve the reference
            if (sm.Schemas && sm.Schemas[refName]) {
              const refSchema = sm.Schemas[refName]
              lines.push(`+"`"+`${indent}    └─ ${refName} 详情:`+"`"+`)
              const refLines = formatSchemaWithRefs(refSchema, sm, indent + '      ')
              lines.push(...refLines)
            }
          } else if (propSchema.Schema.Items?.Schema) {
            const itemType = propSchema.Schema.Items.Schema.Type || 'unknown'
            lines.push(`+"`"+`${indent}  • ${propName}: ${propType}<${itemType}> ${isRequired}`+"`"+`)
          } else {
            lines.push(`+"`"+`${indent}  • ${propName}: ${propType} ${isRequired}`+"`"+`)
          }
        } else {
          lines.push(`+"`"+`${indent}  • ${propName}: ${propType} ${isRequired}`+"`"+`)
        }
        if (propSchema.Schema.Enum) {
          lines.push(`+"`"+`${indent}    允许值: ${JSON.stringify(propSchema.Schema.Enum)}`+"`"+`)
        }
      } else if (propSchema.Ref?.Ref) {
        // Reference to another schema
        const refName = propSchema.Ref.Ref.replace('#/components/schemas/', '')
        lines.push(`+"`"+`${indent}  • ${propName}: ${refName} (引用) ${isRequired}`+"`"+`)
        
        // Try to resolve the reference
        if (sm.Schemas && sm.Schemas[refName]) {
          const refSchema = sm.Schemas[refName]
          lines.push(`+"`"+`${indent}    └─ ${refName} 详情:`+"`"+`)
          const refLines = formatSchemaWithRefs(refSchema, sm, indent + '      ')
          lines.push(...refLines)
        }
      } else {
        lines.push(`+"`"+`${indent}  • ${propName}: unknown ${isRequired}`+"`"+`)
      }
    })
  }
  
  if (schema.Items) {
    if (schema.Items.Schema) {
      lines.push(`+"`"+`${indent}数组元素类型: ${schema.Items.Schema.Type || 'unknown'}`+"`"+`)
      const itemLines = formatSchemaWithRefs(schema.Items.Schema, sm, indent + '  ')
      lines.push(...itemLines)
    } else if (schema.Items.Ref?.Ref) {
      const refName = schema.Items.Ref.Ref.replace('#/components/schemas/', '')
      lines.push(`+"`"+`${indent}数组元素类型: ${refName} (引用)`+"`"+`)
      
      // Try to resolve the reference
      if (sm.Schemas && sm.Schemas[refName]) {
        const refSchema = sm.Schemas[refName]
        lines.push(`+"`"+`${indent}└─ ${refName} 详情:`+"`"+`)
        const refLines = formatSchemaWithRefs(refSchema, sm, indent + '  ')
        lines.push(...refLines)
      }
    }
  }
  
  if (schema.AllOf && schema.AllOf.length > 0) {
    lines.push(`+"`"+`${indent}组合类型 (AllOf):`+"`"+`)
    schema.AllOf.forEach((subSchema: any, index: number) => {
      lines.push(`+"`"+`${indent}  ${index + 1}. `+"`"+`)
      if (subSchema.Schema) {
        const subLines = formatSchemaWithRefs(subSchema.Schema, sm, indent + '    ')
        lines.push(...subLines)
      } else if (subSchema.Ref?.Ref) {
        const refName = subSchema.Ref.Ref.replace('#/components/schemas/', '')
        lines.push(`+"`"+`${indent}    引用: ${refName}`+"`"+`)
        if (sm.Schemas && sm.Schemas[refName]) {
          const refSchema = sm.Schemas[refName]
          const refLines = formatSchemaWithRefs(refSchema, sm, indent + '      ')
          lines.push(...refLines)
        }
      }
    })
  }
  
  if (schema.Enum) {
    lines.push(`+"`"+`${indent}允许值: ${JSON.stringify(schema.Enum)}`+"`"+`)
  }
  
  return lines
}

function handleRequest(req: JSONRPCRequest) {
  const isNotification = (req.id === undefined)
  const id: JSONRPCId = isNotification ? null : (req.id as JSONRPCId)
  const ok = (result: any) => { if (!isNotification) writeResponse({ jsonrpc: '2.0', id, result }) }
  const err = (code: number, message: string, data?: any) => { 
    if (!isNotification) {
      const errorResponse: any = { jsonrpc: '2.0', id, error: { code, message } }
      if (data !== undefined) {
        errorResponse.error.data = data
      }
      writeResponse(errorResponse)
    }
  }

  try {
    switch (req.method) {
      case 'initialize': {
        return ok({
          protocolVersion: '2025-06-18',
          serverInfo: { name: serverName, version: serverVersion },
          capabilities: { tools: { listChanged: false } },
          instructions: 'This server exposes tools to query your API documentation.',
        })
      }
      case 'ping': {
        return ok({})
      }
      case 'notifications/initialized': {
        // Client notifies server it's initialized — do not respond to notifications
        return
      }
      case 'logging/setLevel': {
        // Accept and no-op
        return ok({})
      }
      case 'tools/list': {
        return ok({ tools })
      }
      case 'prompts/list': {
        return ok({ prompts: [], nextCursor: '' })
      }
      case 'resources/list': {
        return ok({ resources: [], nextCursor: '' })
      }
      case 'resources/templates/list': {
        return ok({ resourceTemplates: [], nextCursor: '' })
      }
      case 'tools/call': {
        const { name, arguments: args = {} } = req.params || {}
        if (!name || typeof name !== 'string') return err(-32602, 'invalid tool name')

        if (name === 'listEndpoints') {
          const overview = Methods.formatEndpointsOverview(sm)
          return ok({ content: [{ type: 'text', text: overview }] })
        }
        if (name === 'searchEndpoints') {
          const out = Methods.searchEndpoints(sm, {
            keyword: String(args.keyword || ''),
            tag: String(args.tag || ''),
            method: String(args.method || ''),
            pathPattern: String(args.pathPattern || ''),
          })
          // Format search results as readable text for better AI comprehension
          const textLines = [`+"`"+`找到 ${out.length} 个匹配的接口:`+"`"+`]
          out.forEach((ep, i) => {
            textLines.push('')
            textLines.push(`+"`"+`${i + 1}. ${ep.method.toUpperCase()} ${ep.path}`+"`"+`)
            textLines.push(`+"`"+`   摘要: ${ep.summary}`+"`"+`)
            // Get full endpoint details to show parameters and responses
            const [fullEndpoint, found] = Methods.getEndpointDetails(sm, ep.id)
            if (found && fullEndpoint.Parameters && fullEndpoint.Parameters.length > 0) {
              const requiredParams = fullEndpoint.Parameters.filter((p: any) => p.Required)
              const optionalParams = fullEndpoint.Parameters.filter((p: any) => !p.Required)
              const paramInfo = []
              if (requiredParams.length > 0) {
                paramInfo.push(`+"`"+`必需参数(${requiredParams.length})`+"`"+`)
              }
              if (optionalParams.length > 0) {
                paramInfo.push(`+"`"+`可选参数(${optionalParams.length})`+"`"+`)
              }
              textLines.push(`+"`"+`   参数: ${paramInfo.join(', ')}`+"`"+`)
            }
            if (found && fullEndpoint.Responses && fullEndpoint.Responses.length > 0) {
              const successResponses = fullEndpoint.Responses.filter((r: any) => r.Status.startsWith('2'))
              if (successResponses.length > 0) {
                textLines.push(`+"`"+`   返回: ${successResponses.map((r: any) => r.Status).join(', ')}`+"`"+`)
              }
            }
            textLines.push(`+"`"+`   标签: ${ep.tags.join(', ')}`+"`"+`)
            textLines.push(`+"`"+`   ID: ${ep.id}`+"`"+`)
          })
          return ok({ content: [{ type: 'text', text: textLines.join('\\n') }], structuredContent: out })
        }
        if (name === 'getEndpointDetails') {
          let ep, okFlag
          if (args.id) {
            ;[ep, okFlag] = Methods.getEndpointDetails(sm, String(args.id))
          } else {
            ;[ep, okFlag] = Methods.getEndpointDetails(sm, String(args.method || ''), String(args.path || ''))
          }
          if (!okFlag) return ok({ isError: true, content: [{ type: 'text', text: 'endpoint not found' }] })
          // Format detailed text output for the endpoint
          const textLines = [
            `+"`"+`${(ep as any)?.Method?.toUpperCase()} ${(ep as any)?.Path}`+"`"+`,
            `+"`"+`摘要: ${(ep as any)?.Summary || '无'}`+"`"+`,
            `+"`"+`描述: ${(ep as any)?.Description || '无'}`+"`"+`,
            `+"`"+`标签: ${((ep as any)?.Tags || []).join(', ') || '无'}`+"`"+`
          ]
          
          if ((ep as any)?.Parameters?.length > 0) {
            textLines.push('', '参数:')
            ;(ep as any).Parameters.forEach((param: any) => {
              const required = param.Required ? '[必需]' : '[可选]'
              const type = param.Schema?.Schema?.Type || 'unknown'
              const enumValues = param.Schema?.Schema?.Enum ? `+"`"+` (允许值: ${JSON.stringify(param.Schema.Schema.Enum)})`+"`"+` : ''
              textLines.push(`+"`"+`  • ${param.Name} (${param.In}) - ${type}${enumValues} ${required}`+"`"+`)
            })
          }
          
          if ((ep as any)?.RequestBody) {
            textLines.push('', '请求体:')
            const reqBody = (ep as any).RequestBody
            const required = reqBody.Required ? '[必需]' : '[可选]'
            const contentTypes = reqBody.Content?.map((c: any) => c.Mime).join(', ') || 'unknown'
            textLines.push(`+"`"+`  Content-Type: ${contentTypes} ${required}`+"`"+`)
            
            // Add request schema information
            if (reqBody.Content && reqBody.Content.length > 0) {
              reqBody.Content.forEach((content: any) => {
                if (content.Schema) {
                  textLines.push(`+"`"+`  Schema (${content.Mime}):`+"`"+`)
                  
                  // Handle direct schema
                  if (content.Schema.Schema) {
                    const schema = content.Schema.Schema
                    const schemaLines = formatSchemaWithRefs(schema, sm, '    ')
                    textLines.push(...schemaLines)
                  }
                  
                  // Handle schema reference
                  if (content.Schema.Ref?.Ref) {
                    const refName = content.Schema.Ref.Ref.replace('#/components/schemas/', '')
                    textLines.push(`+"`"+`    引用: ${refName}`+"`"+`)
                    
                    // Try to resolve the reference and show details
                    if (sm.Schemas && sm.Schemas[refName]) {
                      const refSchema = sm.Schemas[refName]
                      textLines.push(`+"`"+`    └─ ${refName} 详情:`+"`"+`)
                      const refLines = formatSchemaWithRefs(refSchema, sm, '      ')
                      textLines.push(...refLines)
                    }
                  }
                }
                if (content.Example) {
                  textLines.push(`+"`"+`  示例: ${JSON.stringify(content.Example)}`+"`"+`)
                }
              })
            }
          }
          
          if ((ep as any)?.Responses?.length > 0) {
            textLines.push('', '响应:')
            ;(ep as any).Responses.forEach((resp: any) => {
              textLines.push(`+"`"+`  • ${resp.Status}: ${resp.Description}`+"`"+`)
              
              // Add response schema information
              if (resp.Content && resp.Content.length > 0) {
                resp.Content.forEach((content: any) => {
                  if (content.Schema) {
                    textLines.push(`+"`"+`    Schema (${content.Mime}):`+"`"+`)
                    
                    // Handle direct schema
                    if (content.Schema.Schema) {
                      const schema = content.Schema.Schema
                      const schemaLines = formatSchemaWithRefs(schema, sm, '      ')
                      textLines.push(...schemaLines)
                    }
                    
                    // Handle schema reference
                    if (content.Schema.Ref?.Ref) {
                      const refName = content.Schema.Ref.Ref.replace('#/components/schemas/', '')
                      textLines.push(`+"`"+`      引用: ${refName}`+"`"+`)
                      
                      // Try to resolve the reference and show details
                      if (sm.Schemas && sm.Schemas[refName]) {
                        const refSchema = sm.Schemas[refName]
                        textLines.push(`+"`"+`      └─ ${refName} 详情:`+"`"+`)
                        const refLines = formatSchemaWithRefs(refSchema, sm, '        ')
                        textLines.push(...refLines)
                      }
                    }
                  }
                  if (content.Example) {
                    textLines.push(`+"`"+`    示例: ${JSON.stringify(content.Example)}`+"`"+`)
                  }
                })
              }
            })
          }
          
          return ok({ structuredContent: ep, content: [{ type: 'text', text: textLines.join('\\n') }] })
        }
        if (name === 'listSchemas') {
          const out = Methods.listSchemas(sm)
          return ok({ content: [{ type: 'text', text: String(out.length) + ' schemas' }], structuredContent: out })
        }
        if (name === 'getSchemaDetails') {
          const [sc, okFlag] = Methods.getSchemaDetails(sm, String(args.name || ''))
          if (!okFlag) return ok({ isError: true, content: [{ type: 'text', text: 'schema not found' }] })
          
          // Format detailed text output for the schema
          const textLines = [
            `+"`"+`Schema: ${sc.Name}`+"`"+`
          ]
          if (sc) {
            const schemaLines = formatSchemaWithRefs(sc, sm, '')
            textLines.push(...schemaLines)
          }
          
          return ok({ structuredContent: sc, content: [{ type: 'text', text: textLines.join('\\n') }] })
        }
        return err(-32601, 'unknown tool: ' + String(name))
      }
      default:
        // Ignore unknown notifications; error on unknown requests
        if (isNotification) return
        return err(-32601, 'method not found: ' + String(req.method))
    }
  } catch (e: any) {
    // Log internal error to stderr for debugging; respond only for requests
    console.error('[mcp-server] error:', e?.message || String(e))
    return err(-32000, e?.message || String(e))
  }
}

// NL-delimited JSON-RPC over stdio
let buf = ''
process.stdin.setEncoding('utf8')
process.stdin.on('data', (chunk) => {
  buf += chunk
  let idx
  while ((idx = buf.indexOf('\n')) >= 0) {
    const line = buf.slice(0, idx).trim()
    buf = buf.slice(idx + 1)
    if (!line) continue
    try {
      const msg = JSON.parse(line) as JSONRPCRequest
      handleRequest(msg)
    } catch (e: any) {
      // Do not emit a JSON-RPC response with id=null; MCP clients expect id to be string/number.
      // Log to stderr for diagnostics and ignore this line.
      console.error('[mcp-server] parse error:', String(e))
    }
  }
})

process.stdin.on('end', () => {
  console.error('[mcp-server] stdin closed, exiting...')
  process.exit(0)
})

process.stdin.on('error', (error) => {
  console.error('[mcp-server] stdin error:', error)
  process.exit(1)
})

// Error handling for uncaught exceptions and unhandled rejections
process.on('uncaughtException', (error) => {
  console.error('[mcp-server] uncaught exception:', error)
  process.exit(1)
})

process.on('unhandledRejection', (reason, promise) => {
  console.error('[mcp-server] unhandled rejection at:', promise, 'reason:', reason)
  process.exit(1)
})

// Handle process termination signals
process.on('SIGINT', () => {
  console.error('[mcp-server] received SIGINT, exiting...')
  process.exit(0)
})

process.on('SIGTERM', () => {
  console.error('[mcp-server] received SIGTERM, exiting...')
  process.exit(0)
})

// Do not exit automatically; let the host manage lifecycle
`) + "\n"
}

func renderSpecModelTs() string {
	return normalize(`// Internal Model (IM) definitions used by the generated MCP tool.

export type HttpMethod =
  | 'get' | 'post' | 'put' | 'delete' | 'patch' | 'head' | 'options' | 'trace'

export interface ServiceModel {
  Title: string
  Version: string
  Description: string
  Servers: Server[]
  Tags: string[]
  Endpoints: EndpointModel[]
  Schemas: Record<string, Schema>
}

export interface Server { URL: string; Description: string }

export interface EndpointModel {
  ID: string // method+path
  Method: HttpMethod
  Path: string
  Summary: string
  Description: string
  Tags: string[]
  Parameters: ParameterModel[]
  RequestBody?: RequestBodyModel
  Responses: ResponseModel[]
}

export interface ParameterModel {
  Name: string
  In: 'path'|'query'|'header'|'cookie'|string
  Required: boolean
  Schema?: SchemaOrRef
}

export interface RequestBodyModel {
  Content: Media[]
  Required: boolean
}

export interface ResponseModel {
  Status: string // 200, 4xx, default
  Description: string
  Content: Media[]
}

export interface Media {
  Mime: string
  Schema?: SchemaOrRef
  Example?: any
}

export interface Schema {
  Name: string
  Type: string
  Properties?: Record<string, SchemaOrRef>
  Required?: string[]
  Items?: SchemaOrRef
  AllOf?: SchemaOrRef[]
  AnyOf?: SchemaOrRef[]
  OneOf?: SchemaOrRef[]
  Description?: string
  Enum?: any[]
  Format?: string
  Example?: any
}

export interface SchemaRef { Ref: string }

export interface SchemaOrRef { Schema?: Schema; Ref?: SchemaRef }
`) + "\n"
}

func renderSpecLoaderTs() string {
	return normalize(`import { readFileSync } from 'fs'
import { fileURLToPath } from 'url'
import { dirname, join } from 'path'
import type { ServiceModel } from './model.js'

export function loadServiceModel(): ServiceModel {
  try {
    const __filename = fileURLToPath(import.meta.url)
    const __dirname = dirname(__filename)
    const modelPath = join(__dirname, 'model.json')
    const modelData = readFileSync(modelPath, 'utf-8')
    return JSON.parse(modelData) as ServiceModel
  } catch (error) {
    console.error('[spec-loader] failed to load model.json:', error)
    throw error
  }
}
`) + "\n"
}

func renderListEndpointsTs() string {
	return normalize(`import type { ServiceModel } from '../../spec/model.js'

export interface EndpointSummary { 
  id: string; 
  method: string; 
  path: string; 
  summary: string; 
  description: string;
  tags: string[];
  parameters: Array<{name: string; in: string; required: boolean; type: string; enum?: any[]}>;
  responses: Array<{status: string; description: string}>;
}

export function listEndpoints(sm: ServiceModel): EndpointSummary[] {
  if (!sm?.Endpoints) return []
  const out = sm.Endpoints.map(ep => ({ 
    id: ep.ID, 
    method: String(ep.Method), 
    path: ep.Path, 
    summary: ep.Summary,
    description: ep.Description || '',
    tags: [...(ep.Tags||[])],
    parameters: (ep.Parameters || []).map(p => ({
      name: p.Name,
      in: p.In,
      required: p.Required,
      type: p.Schema?.Schema?.Type || 'unknown',
      enum: p.Schema?.Schema?.Enum
    })),
    responses: (ep.Responses || []).map(r => ({
      status: r.Status,
      description: r.Description
    }))
  }))
  out.sort((a, b) => a.path === b.path ? a.method.localeCompare(b.method) : a.path.localeCompare(b.path))
  return out
}

// formatEndpointsOverview formats a comprehensive overview of all endpoints
export function formatEndpointsOverview(sm: ServiceModel): string {
  const endpoints = listEndpoints(sm)
  if (endpoints.length === 0) {
    return '无可用接口'
  }

  const lines: string[] = []
  lines.push('API 接口概览 (' + endpoints.length + ' 个接口)')
  lines.push('')

  // 按标签分组统计
  const tagStats = new Map<string, number>()
  const methodStats = new Map<string, number>()
  
  for (const ep of endpoints) {
    const method = ep.method.toUpperCase()
    methodStats.set(method, (methodStats.get(method) || 0) + 1)
    for (const tag of ep.tags) {
      tagStats.set(tag, (tagStats.get(tag) || 0) + 1)
    }
  }
  
  // 显示方法统计
  lines.push('HTTP 方法分布:')
  for (const [method, count] of methodStats.entries()) {
    lines.push('  ' + method + ': ' + count + ' 个接口')
  }
  lines.push('')
  
  // 显示标签统计 (取前10个)
  if (tagStats.size > 0) {
    lines.push('服务模块分布:')
    // 按数量排序
    const tagList = Array.from(tagStats.entries())
      .sort((a, b) => b[1] - a[1])
    
    // 显示前10个最多的标签
    const maxShow = Math.min(10, tagList.length)
    for (let i = 0; i < maxShow; i++) {
      const [tag, count] = tagList[i]
      lines.push('  ' + tag + ': ' + count + ' 个接口')
    }
    if (tagList.length > 10) {
      lines.push('  ... 还有 ' + (tagList.length - 10) + ' 个其他服务模块')
    }
    lines.push('')
  }
  
  // 显示主要路由路径
  lines.push('主要路由路径:')
  const pathPrefixes = new Map<string, number>()
  for (const ep of endpoints) {
    // 提取路径前缀 (前两级路径)
    const parts = ep.path.replace(/^\/|\/$/g, '').split('/')
    let prefix: string
    if (parts.length >= 2 && parts[0] && parts[1]) {
      prefix = '/' + parts[0] + '/' + parts[1]
    } else if (parts.length === 1 && parts[0]) {
      prefix = '/' + parts[0]
    } else {
      prefix = '/'
    }
    pathPrefixes.set(prefix, (pathPrefixes.get(prefix) || 0) + 1)
  }
  
  // 按数量排序路径前缀
  const pathList = Array.from(pathPrefixes.entries())
    .sort((a, b) => b[1] - a[1])
  
  // 显示前10个最常用的路径前缀
  const maxPaths = Math.min(10, pathList.length)
  for (let i = 0; i < maxPaths; i++) {
    const [path, count] = pathList[i]
    lines.push('  ' + path + ': ' + count + ' 个接口')
  }
  if (pathList.length > 10) {
    lines.push('  ... 还有 ' + (pathList.length - 10) + ' 个其他路径')
  }
  lines.push('')
  
  // 显示所有接口端点列表 (功能总结和路由)
  lines.push('所有接口端点:')
  for (const ep of endpoints) {
    const summary = ep.summary || '无描述'
    lines.push('  ' + ep.method.toUpperCase() + ' ' + ep.path + ' - ' + summary)
  }
  
  return lines.join('\\n')
}
`) + "\n"
}

func renderSearchEndpointsTs() string {
	return normalize(`import type { ServiceModel } from '../../spec/model.js'

export interface SearchQuery { keyword?: string; tag?: string; method?: string; pathPattern?: string }
export interface EndpointSearchResult { 
  id: string; 
  method: string; 
  path: string; 
  summary: string; 
  tags: string[];
}

export function searchEndpoints(sm: ServiceModel, q: SearchQuery): EndpointSearchResult[] {
  if (!sm?.Endpoints) return []
  let re: RegExp | undefined
  const pattern = (q?.pathPattern || '').trim()
  if (pattern) {
    try { re = new RegExp(pattern, 'i') } catch { return [] }  // 'i' flag for case-insensitive
  }
  const kw = (q?.keyword || '').trim().toLowerCase()
  const tag = (q?.tag || '').trim().toLowerCase()
  const method = (q?.method || '').trim().toLowerCase()
  const out: EndpointSearchResult[] = []
  for (const ep of sm.Endpoints) {
    if (method && String(ep.Method).toLowerCase() !== method) continue
    if (tag && !(ep.Tags||[]).some(t => t.toLowerCase().includes(tag))) continue
    if (re && !re.test(ep.Path)) continue
  if (kw) {
      const text = ((ep.Summary||'') + '\n' + (ep.Description||'') + '\n' + ep.Path).toLowerCase()
      if (!text.includes(kw)) continue
    }
    out.push({ 
      id: ep.ID, 
      method: String(ep.Method), 
      path: ep.Path, 
      summary: ep.Summary,
      tags: [...(ep.Tags||[])]
    })
  }
  out.sort((a, b) => a.path === b.path ? a.method.localeCompare(b.method) : a.path.localeCompare(b.path))
  return out
}
`) + "\n"
}

func renderGetEndpointDetailsTs() string {
	return normalize(`import type { ServiceModel, EndpointModel } from '../../spec/model.js'

export function getEndpointDetails(sm: ServiceModel, idOrMethod: string, pathOptional?: string): [EndpointModel, true] | [undefined, false] {
  const method = (idOrMethod||'').trim().toLowerCase()
  if (pathOptional === undefined) {
    for (const ep of sm.Endpoints || []) {
      if (ep.ID === idOrMethod) return [ep, true]
    }
    return [undefined, false]
  }
  const path = pathOptional
  for (const ep of sm.Endpoints || []) {
    if (String(ep.Method) === method && ep.Path === path) return [ep, true]
  }
  return [undefined, false]
}
`) + "\n"
}

func renderListSchemasTs() string {
	return normalize(`import type { ServiceModel } from '../../spec/model.js'

export interface SchemaSummary { name: string; description?: string }

export function listSchemas(sm: ServiceModel): SchemaSummary[] {
  const names = Object.keys(sm.Schemas || {})
  names.sort()
  return names.map(n => ({ name: n, description: sm.Schemas[n]?.Description }))
}
`) + "\n"
}

func renderGetSchemaDetailsTs() string {
	return normalize(`import type { ServiceModel, Schema } from '../../spec/model.js'

export function getSchemaDetails(sm: ServiceModel, name: string): [Schema, true] | [undefined, false] {
  const s = sm.Schemas?.[name]
  if (!s) return [undefined, false]
  // shallow copy to avoid mutation by callers
  return [{ ...s }, true]
}
`) + "\n"
}

func renderGeneratedTestsTs() string {
	return normalize(`import { describe, it, expect } from 'vitest'
import { loadServiceModel } from '../src/spec/loader.js'
import * as Methods from '../src/mcp/methods/index.js'

describe('MCP methods', () => {
  it('shows overview and searches endpoints', () => {
    const sm = loadServiceModel()
    const overview = Methods.formatEndpointsOverview(sm)
    expect(typeof overview).toBe('string')
    expect(overview.length).toBeGreaterThan(0)
    // Use a more flexible search test - try common keywords
    const searchKeywords = ['get', 'list', 'api', 'user', 'data']
    let res: any[] = []
    for (const keyword of searchKeywords) {
      res = Methods.searchEndpoints(sm, { keyword })
      if (res && res.length > 0) break
    }
    expect(Array.isArray(res)).toBe(true)
  })

  it('schema details', () => {
    const sm = loadServiceModel()
    const schemas = Methods.listSchemas(sm)
    if (schemas.length > 0) {
      const [det, ok] = Methods.getSchemaDetails(sm, schemas[0].name)
      expect(ok).toBe(true)
      expect(det).toBeDefined()
    } else {
      const [det, ok] = Methods.getSchemaDetails(sm, '__nonexistent__')
      expect(ok).toBe(false)
      expect(det).toBeUndefined()
    }
  })
})
`) + "\n"
}

func renderMethodsIndexTs() string {
	return normalize(`export { listEndpoints, formatEndpointsOverview } from './listEndpoints.js'
export { searchEndpoints } from './searchEndpoints.js'
export { getEndpointDetails } from './getEndpointDetails.js'
export { listSchemas } from './listSchemas.js'
export { getSchemaDetails } from './getSchemaDetails.js'
`) + "\n"
}

// sampleSpecYAML is a small sample used for testdata in the generated project.
const sampleSpecYAML = "" +
	"openapi: 3.0.0\n" +
	"info:\n" +
	"  title: Sample\n" +
	"  version: '1.0.0'\n" +
	"paths:\n" +
	"  /pets:\n" +
	"    get:\n" +
	"      summary: List pets\n" +
	"      tags: [read]\n" +
	"      responses:\n" +
	"        '200':\n" +
	"          description: ok\n" +
	"          content:\n" +
	"            application/json:\n" +
	"              schema:\n" +
	"                type: array\n" +
	"                items:\n" +
	"                  type: string\n"

func renderMCPBManifest(data templateData) string {
	author := map[string]string{"name": "Generated by swagger2mcp"}
	title := data.title()
	manifest := map[string]any{
		"manifest_version": "0.2",
		"name":             data.PackageName,
		"version":          "0.1.0",
		"description":      fmt.Sprintf("Generated MCP tool for %s", title),
		"author":           author,
		"server": map[string]any{
			"type":        "node",
			"entry_point": "dist/index.js",
			"mcp_config": map[string]any{
				"command": "/usr/bin/env",
				"args":    []string{"node", "${__dirname}/dist/index.js"},
			},
		},
		"tools": []map[string]any{
			{"name": "listEndpoints", "description": "Show API overview and routing summary"},
			{"name": "searchEndpoints", "description": "Search endpoints"},
			{"name": "getEndpointDetails", "description": "Get endpoint details"},
			{"name": "listSchemas", "description": "List schemas"},
			{"name": "getSchemaDetails", "description": "Get schema details"},
		},
		"tools_generated": false,
	}
	b, _ := json.MarshalIndent(manifest, "", "  ")
	return string(b) + "\n"
}

func renderEditorConfig() string {
	return normalize(`root = true

[*]
charset = utf-8
end_of_line = lf
insert_final_newline = true
indent_style = space
indent_size = 2
trim_trailing_whitespace = true
`) + "\n"
}

func renderPrettierRC() string {
	cfg := map[string]any{
		"singleQuote":   true,
		"semi":          false,
		"trailingComma": "all",
		"printWidth":    100,
	}
	b, _ := json.MarshalIndent(cfg, "", "  ")
	return string(b) + "\n"
}

func renderESLintRC() string {
	// Minimal ESLint config for TS + Prettier
	cfg := map[string]any{
		"root": true,
		"env": map[string]any{
			"es2021": true,
			"node":   true,
		},
		"parser": "@typescript-eslint/parser",
		"parserOptions": map[string]any{
			"project":     nil,
			"sourceType":  "module",
			"ecmaVersion": 2021,
		},
		"plugins":        []string{"@typescript-eslint"},
		"extends":        []string{"eslint:recommended", "plugin:@typescript-eslint/recommended", "prettier"},
		"ignorePatterns": []string{"dist", "node_modules"},
	}
	b, _ := json.MarshalIndent(cfg, "", "  ")
	return string(b) + "\n"
}

func renderMCPBIgnore() string {
	return normalize(`# Exclude development and source files from the bundle
node_modules/
src/
__tests__/
testdata/
.git/
.github/
.vscode/
.DS_Store
tsconfig.json
package-lock.json
yarn.lock
pnpm-lock.yaml
*.map
*.ts
.eslintrc.json
.prettierrc.json
.editorconfig
Makefile
README.md
`) + "\n"
}

func renderMakefileNpm() string {
	return normalize(`# Simple Makefile for npm/TypeScript MCP tool

.PHONY: help install build test format lint bundle

help:
	@echo "Targets: install build test format lint bundle"

install:
	npm install

build:
	npm run build

bundle:
	# Requires 'mcpb' CLI globally: npm i -g @anthropic-ai/mcpb
	npm run bundle

test:
	npm test

format:
	npm run format

lint:
	npm run lint
`) + "\n"
}
